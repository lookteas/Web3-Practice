# 🎯 实战演练指南

> 通过具体场景和代码示例，让你真正掌握项目的实际应用

---

## 🎬 完整使用流程演示

### 场景设定
假设你是一个 NFT 项目方，要为早期支持者举办一次空投活动：

- **项目名称**：CryptoArt Collection
- **代币名称**：ART Token
- **NFT 系列**：限量版数字艺术品
- **白名单用户**：1000 个早期支持者
- **折扣政策**：白名单用户享受 50% 折扣

---

## 📋 第一步：准备白名单数据

### 1.1 收集用户地址

```javascript
// 假设这是你的白名单用户地址
const whitelistAddresses = [
    "0x1234567890123456789012345678901234567890",
    "0x2345678901234567890123456789012345678901", 
    "0x3456789012345678901234567890123456789012",
    "0x4567890123456789012345678901234567890123",
    // ... 更多地址
];
```

### 1.2 生成 Merkle 树

```javascript
const { MerkleTree } = require('merkletreejs');
const keccak256 = require('keccak256');

// 创建叶子节点
const leaves = whitelistAddresses.map(addr => keccak256(addr));

// 构建 Merkle 树
const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });

// 获取根哈希
const merkleRoot = tree.getHexRoot();
console.log('Merkle Root:', merkleRoot);

// 为特定用户生成证明
function getProofForUser(userAddress) {
    const leaf = keccak256(userAddress);
    const proof = tree.getHexProof(leaf);
    return proof;
}

// 示例：为第一个用户生成证明
const user1Proof = getProofForUser(whitelistAddresses[0]);
console.log('User 1 Proof:', user1Proof);
```

---

## 🚀 第二步：部署合约

### 2.1 部署脚本

```solidity
// Deploy.s.sol
pragma solidity ^0.8.25;

import "forge-std/Script.sol";
import "../src/AirdropToken.sol";
import "../src/AirdropNFT.sol";
import "../src/AirdropMerkleNFTMarket.sol";

contract DeployScript is Script {
    function run() external {
        // 使用私钥开始部署
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);
        
        vm.startBroadcast(deployerPrivateKey);
        
        // 1. 部署代币合约
        AirdropToken token = new AirdropToken(
            "ART Token",    // 代币名称
            "ART",          // 代币符号
            deployer        // 初始所有者
        );
        
        // 2. 部署 NFT 合约
        AirdropNFT nft = new AirdropNFT(
            "CryptoArt Collection",  // NFT 名称
            "CAC",                   // NFT 符号
            deployer                 // 初始所有者
        );
        
        // 3. 部署市场合约
        bytes32 merkleRoot = 0x1234...; // 替换为实际的 Merkle Root
        AirdropMerkleNFTMarket market = new AirdropMerkleNFTMarket(
            address(token),
            address(nft),
            merkleRoot,
            deployer
        );
        
        vm.stopBroadcast();
        
        // 输出合约地址
        console.log("Token deployed to:", address(token));
        console.log("NFT deployed to:", address(nft));
        console.log("Market deployed to:", address(market));
    }
}
```

### 2.2 执行部署

```bash
# 设置环境变量
export PRIVATE_KEY=0x1234...
export RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID

# 执行部署
forge script script/Deploy.s.sol --rpc-url $RPC_URL --private-key $PRIVATE_KEY --broadcast
```

---

## 🎨 第三步：准备 NFT 商品

### 3.1 铸造 NFT

```javascript
// 使用 ethers.js 与合约交互
const { ethers } = require('ethers');

// 连接到网络
const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

// 连接到 NFT 合约
const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, wallet);

// 铸造 NFT
async function mintNFTs() {
    const tokenURIs = [
        "https://ipfs.io/ipfs/QmArt1...",  // 第一个艺术品的元数据
        "https://ipfs.io/ipfs/QmArt2...",  // 第二个艺术品的元数据
        "https://ipfs.io/ipfs/QmArt3...",  // 第三个艺术品的元数据
    ];
    
    for (let i = 0; i < tokenURIs.length; i++) {
        const tx = await nftContract.mint(wallet.address, tokenURIs[i]);
        await tx.wait();
        console.log(`NFT #${i+1} minted: ${tx.hash}`);
    }
}

mintNFTs();
```

### 3.2 上架 NFT

```javascript
// 上架 NFT 到市场
async function listNFTs() {
    const prices = [
        ethers.utils.parseEther("1.0"),    // NFT #1: 1 ART
        ethers.utils.parseEther("2.0"),    // NFT #2: 2 ART  
        ethers.utils.parseEther("0.5"),    // NFT #3: 0.5 ART
    ];
    
    for (let i = 0; i < prices.length; i++) {
        const tokenId = i + 1;
        const tx = await nftContract.listToken(tokenId, prices[i]);
        await tx.wait();
        console.log(`NFT #${tokenId} listed for ${ethers.utils.formatEther(prices[i])} ART`);
    }
}

listNFTs();
```

---

## 💰 第四步：分发代币

### 4.1 给用户分发代币

```javascript
// 连接到代币合约
const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, wallet);

// 给白名单用户分发代币
async function distributeTokens() {
    const amount = ethers.utils.parseEther("10.0"); // 每人 10 个代币
    
    for (const address of whitelistAddresses) {
        const tx = await tokenContract.mint(address, amount);
        await tx.wait();
        console.log(`Minted 10 ART to ${address}`);
    }
}

distributeTokens();
```

---

## 🛒 第五步：用户购买流程

### 5.1 白名单用户购买（享受折扣）

```javascript
// 用户端代码
async function buyNFTWithDiscount(userWallet, tokenId, merkleProof) {
    // 连接到合约
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, userWallet);
    const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, userWallet);
    
    // 1. 获取 NFT 价格
    const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, userWallet);
    const originalPrice = await nftContract.tokenPrices(tokenId);
    
    // 2. 计算折扣价格
    const discountedPrice = await marketContract.calculateDiscountedPrice(originalPrice);
    console.log(`Original price: ${ethers.utils.formatEther(originalPrice)} ART`);
    console.log(`Discounted price: ${ethers.utils.formatEther(discountedPrice)} ART`);
    
    // 3. 准备 permit 签名
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1小时后过期
    
    // 获取 nonce
    const nonce = await tokenContract.nonces(userWallet.address);
    
    // 构建签名数据
    const domain = {
        name: await tokenContract.name(),
        version: '1',
        chainId: await userWallet.getChainId(),
        verifyingContract: tokenContract.address
    };
    
    const types = {
        Permit: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' }
        ]
    };
    
    const values = {
        owner: userWallet.address,
        spender: marketContract.address,
        value: discountedPrice,
        nonce: nonce,
        deadline: deadline
    };
    
    // 签名
    const signature = await userWallet._signTypedData(domain, types, values);
    const { v, r, s } = ethers.utils.splitSignature(signature);
    
    // 4. 使用 Multicall 一次性完成预付款和购买
    const permitCalldata = marketContract.interface.encodeFunctionData(
        'permitPrePay',
        [discountedPrice, deadline, v, r, s]
    );
    
    const claimCalldata = marketContract.interface.encodeFunctionData(
        'claimNFT',
        [tokenId, merkleProof]
    );
    
    // 执行 multicall
    const tx = await marketContract.multicall([permitCalldata, claimCalldata]);
    await tx.wait();
    
    console.log(`Successfully bought NFT #${tokenId} with discount!`);
    console.log(`Transaction hash: ${tx.hash}`);
}

// 使用示例
const userWallet = new ethers.Wallet(USER_PRIVATE_KEY, provider);
const tokenId = 1;
const proof = getProofForUser(userWallet.address);

buyNFTWithDiscount(userWallet, tokenId, proof);
```

### 5.2 非白名单用户购买（原价）

```javascript
async function buyNFTRegularPrice(userWallet, tokenId) {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, userWallet);
    const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, userWallet);
    const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, userWallet);
    
    // 获取原价
    const originalPrice = await nftContract.tokenPrices(tokenId);
    
    // 预付款（使用传统方式）
    const approveTx = await tokenContract.approve(marketContract.address, originalPrice);
    await approveTx.wait();
    
    const prepayTx = await tokenContract.transferFrom(
        userWallet.address, 
        marketContract.address, 
        originalPrice
    );
    await prepayTx.wait();
    
    // 更新预付款记录
    // 注意：这里需要直接调用合约的内部函数，实际中可能需要不同的实现
    
    // 购买 NFT（提供空的 proof）
    const claimTx = await marketContract.claimNFT(tokenId, []);
    await claimTx.wait();
    
    console.log(`Successfully bought NFT #${tokenId} at regular price!`);
}
```

---

## 📊 第六步：监控和管理

### 6.1 监听事件

```javascript
// 监听市场事件
function setupEventListeners() {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, provider);
    
    // 监听预付款事件
    marketContract.on('PrePaid', (user, amount, event) => {
        console.log(`User ${user} prepaid ${ethers.utils.formatEther(amount)} ART`);
    });
    
    // 监听 NFT 购买事件
    marketContract.on('NFTClaimed', (user, tokenId, price, event) => {
        console.log(`User ${user} bought NFT #${tokenId} for ${ethers.utils.formatEther(price)} ART`);
    });
    
    // 监听 Merkle Root 更新事件
    marketContract.on('MerkleRootUpdated', (newRoot, event) => {
        console.log(`Merkle root updated to: ${newRoot}`);
    });
}

setupEventListeners();
```

### 6.2 管理功能

```javascript
// 管理员功能
async function adminFunctions(adminWallet) {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, adminWallet);
    
    // 更新白名单
    async function updateWhitelist(newAddresses) {
        const leaves = newAddresses.map(addr => keccak256(addr));
        const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });
        const newRoot = tree.getHexRoot();
        
        const tx = await marketContract.updateMerkleRoot(newRoot);
        await tx.wait();
        console.log(`Whitelist updated. New root: ${newRoot}`);
    }
    
    // 紧急提取
    async function emergencyWithdraw() {
        const tx = await marketContract.emergencyWithdraw();
        await tx.wait();
        console.log('Emergency withdrawal completed');
    }
    
    // 查询合约状态
    async function getContractStatus() {
        const tokenBalance = await marketContract.getContractTokenBalance();
        const merkleRoot = await marketContract.merkleRoot();
        
        console.log(`Contract token balance: ${ethers.utils.formatEther(tokenBalance)} ART`);
        console.log(`Current merkle root: ${merkleRoot}`);
    }
    
    return { updateWhitelist, emergencyWithdraw, getContractStatus };
}
```

---

## 🧪 第七步：测试场景

### 7.1 单元测试示例

```solidity
// AirdropMerkleNFTMarket.t.sol
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "../src/AirdropMerkleNFTMarket.sol";
import "../src/AirdropToken.sol";
import "../src/AirdropNFT.sol";

contract AirdropMerkleNFTMarketTest is Test {
    AirdropToken token;
    AirdropNFT nft;
    AirdropMerkleNFTMarket market;
    
    address user1;
    address user2;
    uint256 user1PrivateKey;
    uint256 user2PrivateKey;
    
    bytes32 merkleRoot;
    bytes32[] user1Proof;
    
    function setUp() public {
        // 创建测试用户
        (user1, user1PrivateKey) = makeAddrAndKey("user1");
        (user2, user2PrivateKey) = makeAddrAndKey("user2");
        
        // 部署合约
        token = new AirdropToken("Test Token", "TEST", address(this));
        nft = new AirdropNFT("Test NFT", "TNFT", address(this));
        
        // 设置 Merkle 树（只包含 user1）
        merkleRoot = 0x...; // 预计算的根哈希
        user1Proof = [bytes32(0x...)]; // 预计算的证明
        
        market = new AirdropMerkleNFTMarket(
            address(token),
            address(nft),
            merkleRoot,
            address(this)
        );
        
        // 准备测试数据
        token.mint(user1, 1000 ether);
        token.mint(user2, 1000 ether);
        
        nft.mint(address(this), "https://test.com/1");
        nft.listToken(1, 1 ether);
    }
    
    function testWhitelistUserCanBuyWithDiscount() public {
        vm.startPrank(user1);
        
        // 1. 创建 permit 签名
        uint256 deadline = block.timestamp + 1 hours;
        (uint8 v, bytes32 r, bytes32 s) = createPermitSignature(
            user1,
            address(market),
            0.5 ether, // 折扣价格
            deadline,
            user1PrivateKey
        );
        
        // 2. 预付款
        market.permitPrePay(0.5 ether, deadline, v, r, s);
        
        // 3. 购买 NFT
        market.claimNFT(1, user1Proof);
        
        // 验证结果
        assertEq(nft.ownerOf(1), user1);
        assertEq(market.hasClaimed(user1), true);
        
        vm.stopPrank();
    }
    
    function testNonWhitelistUserPaysFullPrice() public {
        vm.startPrank(user2);
        
        // 1. 传统授权方式
        token.approve(address(market), 1 ether);
        token.transferFrom(user2, address(market), 1 ether);
        
        // 手动更新预付款（在实际合约中需要不同的实现）
        // 这里简化处理
        
        // 2. 购买 NFT（空证明）
        bytes32[] memory emptyProof;
        market.claimNFT(1, emptyProof);
        
        // 验证结果
        assertEq(nft.ownerOf(1), user2);
        
        vm.stopPrank();
    }
    
    function createPermitSignature(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 privateKey
    ) internal view returns (uint8 v, bytes32 r, bytes32 s) {
        // 实现 permit 签名逻辑
        // ... 签名代码
    }
}
```

### 7.2 集成测试

```javascript
// 完整流程测试
async function integrationTest() {
    console.log("🧪 开始集成测试...");
    
    // 1. 部署合约
    console.log("1. 部署合约...");
    const contracts = await deployContracts();
    
    // 2. 设置初始状态
    console.log("2. 设置初始状态...");
    await setupInitialState(contracts);
    
    // 3. 测试白名单用户购买
    console.log("3. 测试白名单用户购买...");
    await testWhitelistPurchase(contracts);
    
    // 4. 测试非白名单用户购买
    console.log("4. 测试非白名单用户购买...");
    await testRegularPurchase(contracts);
    
    // 5. 测试管理功能
    console.log("5. 测试管理功能...");
    await testAdminFunctions(contracts);
    
    console.log("✅ 集成测试完成！");
}

integrationTest().catch(console.error);
```

---

## 🎯 实际应用场景

### 场景 1：游戏道具空投

```javascript
// 游戏公司为玩家空投限量武器
const gameItemAirdrop = {
    // 白名单：活跃玩家
    whitelist: getActivePlayers(),
    
    // NFT：游戏武器
    items: [
        { name: "传说之剑", rarity: "legendary", price: "10 GAME" },
        { name: "魔法法杖", rarity: "epic", price: "5 GAME" },
        { name: "钢铁盾牌", rarity: "rare", price: "2 GAME" }
    ],
    
    // 折扣：VIP 玩家 50% 折扣
    discount: 50
};
```

### 场景 2：艺术品收藏空投

```javascript
// 艺术家为收藏家空投数字艺术品
const artCollectionAirdrop = {
    // 白名单：早期收藏家
    whitelist: getEarlyCollectors(),
    
    // NFT：数字艺术品
    artworks: [
        { title: "数字梦境", artist: "CryptoArtist", price: "1 ETH" },
        { title: "像素宇宙", artist: "PixelMaster", price: "0.5 ETH" },
        { title: "抽象未来", artist: "AbstractVision", price: "2 ETH" }
    ],
    
    // 折扣：收藏家专享
    discount: 30
};
```

### 场景 3：会员制商店

```javascript
// 品牌为会员提供专属商品
const membershipStore = {
    // 白名单：会员用户
    whitelist: getMemberAddresses(),
    
    // NFT：专属商品
    products: [
        { name: "限量版 T恤", category: "fashion", price: "50 BRAND" },
        { name: "纪念徽章", category: "collectible", price: "20 BRAND" },
        { name: "VIP 通行证", category: "access", price: "100 BRAND" }
    ],
    
    // 折扣：会员专享
    discount: 25
};
```

---

## 🔧 故障排除指南

### 常见错误及解决方案

#### 1. "Invalid proof" 错误

```javascript
// 问题：Merkle 证明验证失败
// 原因：证明路径不正确或用户不在白名单中

// 解决方案：
function debugMerkleProof(userAddress, proof, merkleRoot) {
    const leaf = keccak256(userAddress);
    const isValid = MerkleTree.verify(proof, merkleRoot, leaf);
    
    console.log(`User: ${userAddress}`);
    console.log(`Leaf: ${leaf}`);
    console.log(`Proof: ${proof}`);
    console.log(`Root: ${merkleRoot}`);
    console.log(`Valid: ${isValid}`);
    
    if (!isValid) {
        console.log("❌ 用户不在白名单中或证明路径错误");
        // 重新生成证明或检查白名单
    }
}
```

#### 2. "Already claimed" 错误

```javascript
// 问题：用户已经领取过 NFT
// 解决方案：检查用户状态

async function checkUserStatus(userAddress) {
    const hasClaimed = await market.hasClaimed(userAddress);
    const prepaidAmount = await market.getUserPrepaidAmount(userAddress);
    
    console.log(`User ${userAddress}:`);
    console.log(`- Has claimed: ${hasClaimed}`);
    console.log(`- Prepaid amount: ${ethers.utils.formatEther(prepaidAmount)} tokens`);
    
    if (hasClaimed) {
        console.log("❌ 用户已经领取过，无法再次领取");
    }
}
```

#### 3. "Insufficient prepaid amount" 错误

```javascript
// 问题：预付款不足
// 解决方案：检查余额和预付款

async function checkBalances(userAddress, requiredAmount) {
    const tokenBalance = await token.balanceOf(userAddress);
    const prepaidAmount = await market.getUserPrepaidAmount(userAddress);
    
    console.log(`Required: ${ethers.utils.formatEther(requiredAmount)}`);
    console.log(`Token balance: ${ethers.utils.formatEther(tokenBalance)}`);
    console.log(`Prepaid amount: ${ethers.utils.formatEther(prepaidAmount)}`);
    
    if (prepaidAmount.lt(requiredAmount)) {
        const needed = requiredAmount.sub(prepaidAmount);
        console.log(`❌ 需要额外预付 ${ethers.utils.formatEther(needed)} tokens`);
    }
}
```

---

## 📈 性能优化建议

### 1. Gas 优化

```solidity
// 优化前：多次存储写入
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external {
    hasClaimed[msg.sender] = true;           // 写入 1
    prepaidAmounts[msg.sender] -= price;     // 写入 2
    // ... 其他操作
}

// 优化后：批量更新
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external {
    // 先计算所有值，然后一次性更新
    uint256 newPrepaidAmount = prepaidAmounts[msg.sender] - price;
    
    hasClaimed[msg.sender] = true;
    prepaidAmounts[msg.sender] = newPrepaidAmount;
}
```

### 2. 前端优化

```javascript
// 使用缓存减少 RPC 调用
class ContractCache {
    constructor() {
        this.cache = new Map();
        this.ttl = 60000; // 1分钟缓存
    }
    
    async get(key, fetcher) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            return cached.value;
        }
        
        const value = await fetcher();
        this.cache.set(key, { value, timestamp: Date.now() });
        return value;
    }
}

const cache = new ContractCache();

// 缓存 NFT 价格查询
async function getNFTPrice(tokenId) {
    return cache.get(`price_${tokenId}`, async () => {
        return await nft.tokenPrices(tokenId);
    });
}
```

---

## 🎓 学习总结

通过这个实战演练，你应该掌握了：

✅ **完整的项目开发流程**：从需求分析到部署上线
✅ **Merkle 树的实际应用**：白名单验证和 gas 优化
✅ **Permit 机制的使用**：提升用户体验
✅ **Multicall 的实现**：批量操作和原子性
✅ **事件监听和状态管理**：实时数据更新
✅ **错误处理和调试技巧**：快速定位问题
✅ **性能优化策略**：降低成本提升效率

### 下一步学习建议

1. **深入学习 DeFi 协议**：Uniswap、Compound、Aave
2. **掌握跨链技术**：Layer 2、桥接协议
3. **学习前端集成**：React + Web3.js/Ethers.js
4. **了解安全审计**：常见漏洞和防护措施
5. **参与开源项目**：贡献代码，积累经验

记住：**实践是最好的老师，不断动手才能真正掌握 Web3 开发！** 🚀