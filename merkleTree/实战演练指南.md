# ğŸ¯ å®æˆ˜æ¼”ç»ƒæŒ‡å—

> é€šè¿‡å…·ä½“åœºæ™¯å’Œä»£ç ç¤ºä¾‹ï¼Œè®©ä½ çœŸæ­£æŒæ¡é¡¹ç›®çš„å®é™…åº”ç”¨

---

## ğŸ¬ å®Œæ•´ä½¿ç”¨æµç¨‹æ¼”ç¤º

### åœºæ™¯è®¾å®š
å‡è®¾ä½ æ˜¯ä¸€ä¸ª NFT é¡¹ç›®æ–¹ï¼Œè¦ä¸ºæ—©æœŸæ”¯æŒè€…ä¸¾åŠä¸€æ¬¡ç©ºæŠ•æ´»åŠ¨ï¼š

- **é¡¹ç›®åç§°**ï¼šCryptoArt Collection
- **ä»£å¸åç§°**ï¼šART Token
- **NFT ç³»åˆ—**ï¼šé™é‡ç‰ˆæ•°å­—è‰ºæœ¯å“
- **ç™½åå•ç”¨æˆ·**ï¼š1000 ä¸ªæ—©æœŸæ”¯æŒè€…
- **æŠ˜æ‰£æ”¿ç­–**ï¼šç™½åå•ç”¨æˆ·äº«å— 50% æŠ˜æ‰£

---

## ğŸ“‹ ç¬¬ä¸€æ­¥ï¼šå‡†å¤‡ç™½åå•æ•°æ®

### 1.1 æ”¶é›†ç”¨æˆ·åœ°å€

```javascript
// å‡è®¾è¿™æ˜¯ä½ çš„ç™½åå•ç”¨æˆ·åœ°å€
const whitelistAddresses = [
    "0x1234567890123456789012345678901234567890",
    "0x2345678901234567890123456789012345678901", 
    "0x3456789012345678901234567890123456789012",
    "0x4567890123456789012345678901234567890123",
    // ... æ›´å¤šåœ°å€
];
```

### 1.2 ç”Ÿæˆ Merkle æ ‘

```javascript
const { MerkleTree } = require('merkletreejs');
const keccak256 = require('keccak256');

// åˆ›å»ºå¶å­èŠ‚ç‚¹
const leaves = whitelistAddresses.map(addr => keccak256(addr));

// æ„å»º Merkle æ ‘
const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });

// è·å–æ ¹å“ˆå¸Œ
const merkleRoot = tree.getHexRoot();
console.log('Merkle Root:', merkleRoot);

// ä¸ºç‰¹å®šç”¨æˆ·ç”Ÿæˆè¯æ˜
function getProofForUser(userAddress) {
    const leaf = keccak256(userAddress);
    const proof = tree.getHexProof(leaf);
    return proof;
}

// ç¤ºä¾‹ï¼šä¸ºç¬¬ä¸€ä¸ªç”¨æˆ·ç”Ÿæˆè¯æ˜
const user1Proof = getProofForUser(whitelistAddresses[0]);
console.log('User 1 Proof:', user1Proof);
```

---

## ğŸš€ ç¬¬äºŒæ­¥ï¼šéƒ¨ç½²åˆçº¦

### 2.1 éƒ¨ç½²è„šæœ¬

```solidity
// Deploy.s.sol
pragma solidity ^0.8.25;

import "forge-std/Script.sol";
import "../src/AirdropToken.sol";
import "../src/AirdropNFT.sol";
import "../src/AirdropMerkleNFTMarket.sol";

contract DeployScript is Script {
    function run() external {
        // ä½¿ç”¨ç§é’¥å¼€å§‹éƒ¨ç½²
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);
        
        vm.startBroadcast(deployerPrivateKey);
        
        // 1. éƒ¨ç½²ä»£å¸åˆçº¦
        AirdropToken token = new AirdropToken(
            "ART Token",    // ä»£å¸åç§°
            "ART",          // ä»£å¸ç¬¦å·
            deployer        // åˆå§‹æ‰€æœ‰è€…
        );
        
        // 2. éƒ¨ç½² NFT åˆçº¦
        AirdropNFT nft = new AirdropNFT(
            "CryptoArt Collection",  // NFT åç§°
            "CAC",                   // NFT ç¬¦å·
            deployer                 // åˆå§‹æ‰€æœ‰è€…
        );
        
        // 3. éƒ¨ç½²å¸‚åœºåˆçº¦
        bytes32 merkleRoot = 0x1234...; // æ›¿æ¢ä¸ºå®é™…çš„ Merkle Root
        AirdropMerkleNFTMarket market = new AirdropMerkleNFTMarket(
            address(token),
            address(nft),
            merkleRoot,
            deployer
        );
        
        vm.stopBroadcast();
        
        // è¾“å‡ºåˆçº¦åœ°å€
        console.log("Token deployed to:", address(token));
        console.log("NFT deployed to:", address(nft));
        console.log("Market deployed to:", address(market));
    }
}
```

### 2.2 æ‰§è¡Œéƒ¨ç½²

```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
export PRIVATE_KEY=0x1234...
export RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID

# æ‰§è¡Œéƒ¨ç½²
forge script script/Deploy.s.sol --rpc-url $RPC_URL --private-key $PRIVATE_KEY --broadcast
```

---

## ğŸ¨ ç¬¬ä¸‰æ­¥ï¼šå‡†å¤‡ NFT å•†å“

### 3.1 é“¸é€  NFT

```javascript
// ä½¿ç”¨ ethers.js ä¸åˆçº¦äº¤äº’
const { ethers } = require('ethers');

// è¿æ¥åˆ°ç½‘ç»œ
const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

// è¿æ¥åˆ° NFT åˆçº¦
const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, wallet);

// é“¸é€  NFT
async function mintNFTs() {
    const tokenURIs = [
        "https://ipfs.io/ipfs/QmArt1...",  // ç¬¬ä¸€ä¸ªè‰ºæœ¯å“çš„å…ƒæ•°æ®
        "https://ipfs.io/ipfs/QmArt2...",  // ç¬¬äºŒä¸ªè‰ºæœ¯å“çš„å…ƒæ•°æ®
        "https://ipfs.io/ipfs/QmArt3...",  // ç¬¬ä¸‰ä¸ªè‰ºæœ¯å“çš„å…ƒæ•°æ®
    ];
    
    for (let i = 0; i < tokenURIs.length; i++) {
        const tx = await nftContract.mint(wallet.address, tokenURIs[i]);
        await tx.wait();
        console.log(`NFT #${i+1} minted: ${tx.hash}`);
    }
}

mintNFTs();
```

### 3.2 ä¸Šæ¶ NFT

```javascript
// ä¸Šæ¶ NFT åˆ°å¸‚åœº
async function listNFTs() {
    const prices = [
        ethers.utils.parseEther("1.0"),    // NFT #1: 1 ART
        ethers.utils.parseEther("2.0"),    // NFT #2: 2 ART  
        ethers.utils.parseEther("0.5"),    // NFT #3: 0.5 ART
    ];
    
    for (let i = 0; i < prices.length; i++) {
        const tokenId = i + 1;
        const tx = await nftContract.listToken(tokenId, prices[i]);
        await tx.wait();
        console.log(`NFT #${tokenId} listed for ${ethers.utils.formatEther(prices[i])} ART`);
    }
}

listNFTs();
```

---

## ğŸ’° ç¬¬å››æ­¥ï¼šåˆ†å‘ä»£å¸

### 4.1 ç»™ç”¨æˆ·åˆ†å‘ä»£å¸

```javascript
// è¿æ¥åˆ°ä»£å¸åˆçº¦
const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, wallet);

// ç»™ç™½åå•ç”¨æˆ·åˆ†å‘ä»£å¸
async function distributeTokens() {
    const amount = ethers.utils.parseEther("10.0"); // æ¯äºº 10 ä¸ªä»£å¸
    
    for (const address of whitelistAddresses) {
        const tx = await tokenContract.mint(address, amount);
        await tx.wait();
        console.log(`Minted 10 ART to ${address}`);
    }
}

distributeTokens();
```

---

## ğŸ›’ ç¬¬äº”æ­¥ï¼šç”¨æˆ·è´­ä¹°æµç¨‹

### 5.1 ç™½åå•ç”¨æˆ·è´­ä¹°ï¼ˆäº«å—æŠ˜æ‰£ï¼‰

```javascript
// ç”¨æˆ·ç«¯ä»£ç 
async function buyNFTWithDiscount(userWallet, tokenId, merkleProof) {
    // è¿æ¥åˆ°åˆçº¦
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, userWallet);
    const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, userWallet);
    
    // 1. è·å– NFT ä»·æ ¼
    const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, userWallet);
    const originalPrice = await nftContract.tokenPrices(tokenId);
    
    // 2. è®¡ç®—æŠ˜æ‰£ä»·æ ¼
    const discountedPrice = await marketContract.calculateDiscountedPrice(originalPrice);
    console.log(`Original price: ${ethers.utils.formatEther(originalPrice)} ART`);
    console.log(`Discounted price: ${ethers.utils.formatEther(discountedPrice)} ART`);
    
    // 3. å‡†å¤‡ permit ç­¾å
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1å°æ—¶åè¿‡æœŸ
    
    // è·å– nonce
    const nonce = await tokenContract.nonces(userWallet.address);
    
    // æ„å»ºç­¾åæ•°æ®
    const domain = {
        name: await tokenContract.name(),
        version: '1',
        chainId: await userWallet.getChainId(),
        verifyingContract: tokenContract.address
    };
    
    const types = {
        Permit: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' }
        ]
    };
    
    const values = {
        owner: userWallet.address,
        spender: marketContract.address,
        value: discountedPrice,
        nonce: nonce,
        deadline: deadline
    };
    
    // ç­¾å
    const signature = await userWallet._signTypedData(domain, types, values);
    const { v, r, s } = ethers.utils.splitSignature(signature);
    
    // 4. ä½¿ç”¨ Multicall ä¸€æ¬¡æ€§å®Œæˆé¢„ä»˜æ¬¾å’Œè´­ä¹°
    const permitCalldata = marketContract.interface.encodeFunctionData(
        'permitPrePay',
        [discountedPrice, deadline, v, r, s]
    );
    
    const claimCalldata = marketContract.interface.encodeFunctionData(
        'claimNFT',
        [tokenId, merkleProof]
    );
    
    // æ‰§è¡Œ multicall
    const tx = await marketContract.multicall([permitCalldata, claimCalldata]);
    await tx.wait();
    
    console.log(`Successfully bought NFT #${tokenId} with discount!`);
    console.log(`Transaction hash: ${tx.hash}`);
}

// ä½¿ç”¨ç¤ºä¾‹
const userWallet = new ethers.Wallet(USER_PRIVATE_KEY, provider);
const tokenId = 1;
const proof = getProofForUser(userWallet.address);

buyNFTWithDiscount(userWallet, tokenId, proof);
```

### 5.2 éç™½åå•ç”¨æˆ·è´­ä¹°ï¼ˆåŸä»·ï¼‰

```javascript
async function buyNFTRegularPrice(userWallet, tokenId) {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, userWallet);
    const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, userWallet);
    const nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, userWallet);
    
    // è·å–åŸä»·
    const originalPrice = await nftContract.tokenPrices(tokenId);
    
    // é¢„ä»˜æ¬¾ï¼ˆä½¿ç”¨ä¼ ç»Ÿæ–¹å¼ï¼‰
    const approveTx = await tokenContract.approve(marketContract.address, originalPrice);
    await approveTx.wait();
    
    const prepayTx = await tokenContract.transferFrom(
        userWallet.address, 
        marketContract.address, 
        originalPrice
    );
    await prepayTx.wait();
    
    // æ›´æ–°é¢„ä»˜æ¬¾è®°å½•
    // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ç›´æ¥è°ƒç”¨åˆçº¦çš„å†…éƒ¨å‡½æ•°ï¼Œå®é™…ä¸­å¯èƒ½éœ€è¦ä¸åŒçš„å®ç°
    
    // è´­ä¹° NFTï¼ˆæä¾›ç©ºçš„ proofï¼‰
    const claimTx = await marketContract.claimNFT(tokenId, []);
    await claimTx.wait();
    
    console.log(`Successfully bought NFT #${tokenId} at regular price!`);
}
```

---

## ğŸ“Š ç¬¬å…­æ­¥ï¼šç›‘æ§å’Œç®¡ç†

### 6.1 ç›‘å¬äº‹ä»¶

```javascript
// ç›‘å¬å¸‚åœºäº‹ä»¶
function setupEventListeners() {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, provider);
    
    // ç›‘å¬é¢„ä»˜æ¬¾äº‹ä»¶
    marketContract.on('PrePaid', (user, amount, event) => {
        console.log(`User ${user} prepaid ${ethers.utils.formatEther(amount)} ART`);
    });
    
    // ç›‘å¬ NFT è´­ä¹°äº‹ä»¶
    marketContract.on('NFTClaimed', (user, tokenId, price, event) => {
        console.log(`User ${user} bought NFT #${tokenId} for ${ethers.utils.formatEther(price)} ART`);
    });
    
    // ç›‘å¬ Merkle Root æ›´æ–°äº‹ä»¶
    marketContract.on('MerkleRootUpdated', (newRoot, event) => {
        console.log(`Merkle root updated to: ${newRoot}`);
    });
}

setupEventListeners();
```

### 6.2 ç®¡ç†åŠŸèƒ½

```javascript
// ç®¡ç†å‘˜åŠŸèƒ½
async function adminFunctions(adminWallet) {
    const marketContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, adminWallet);
    
    // æ›´æ–°ç™½åå•
    async function updateWhitelist(newAddresses) {
        const leaves = newAddresses.map(addr => keccak256(addr));
        const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });
        const newRoot = tree.getHexRoot();
        
        const tx = await marketContract.updateMerkleRoot(newRoot);
        await tx.wait();
        console.log(`Whitelist updated. New root: ${newRoot}`);
    }
    
    // ç´§æ€¥æå–
    async function emergencyWithdraw() {
        const tx = await marketContract.emergencyWithdraw();
        await tx.wait();
        console.log('Emergency withdrawal completed');
    }
    
    // æŸ¥è¯¢åˆçº¦çŠ¶æ€
    async function getContractStatus() {
        const tokenBalance = await marketContract.getContractTokenBalance();
        const merkleRoot = await marketContract.merkleRoot();
        
        console.log(`Contract token balance: ${ethers.utils.formatEther(tokenBalance)} ART`);
        console.log(`Current merkle root: ${merkleRoot}`);
    }
    
    return { updateWhitelist, emergencyWithdraw, getContractStatus };
}
```

---

## ğŸ§ª ç¬¬ä¸ƒæ­¥ï¼šæµ‹è¯•åœºæ™¯

### 7.1 å•å…ƒæµ‹è¯•ç¤ºä¾‹

```solidity
// AirdropMerkleNFTMarket.t.sol
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "../src/AirdropMerkleNFTMarket.sol";
import "../src/AirdropToken.sol";
import "../src/AirdropNFT.sol";

contract AirdropMerkleNFTMarketTest is Test {
    AirdropToken token;
    AirdropNFT nft;
    AirdropMerkleNFTMarket market;
    
    address user1;
    address user2;
    uint256 user1PrivateKey;
    uint256 user2PrivateKey;
    
    bytes32 merkleRoot;
    bytes32[] user1Proof;
    
    function setUp() public {
        // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
        (user1, user1PrivateKey) = makeAddrAndKey("user1");
        (user2, user2PrivateKey) = makeAddrAndKey("user2");
        
        // éƒ¨ç½²åˆçº¦
        token = new AirdropToken("Test Token", "TEST", address(this));
        nft = new AirdropNFT("Test NFT", "TNFT", address(this));
        
        // è®¾ç½® Merkle æ ‘ï¼ˆåªåŒ…å« user1ï¼‰
        merkleRoot = 0x...; // é¢„è®¡ç®—çš„æ ¹å“ˆå¸Œ
        user1Proof = [bytes32(0x...)]; // é¢„è®¡ç®—çš„è¯æ˜
        
        market = new AirdropMerkleNFTMarket(
            address(token),
            address(nft),
            merkleRoot,
            address(this)
        );
        
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        token.mint(user1, 1000 ether);
        token.mint(user2, 1000 ether);
        
        nft.mint(address(this), "https://test.com/1");
        nft.listToken(1, 1 ether);
    }
    
    function testWhitelistUserCanBuyWithDiscount() public {
        vm.startPrank(user1);
        
        // 1. åˆ›å»º permit ç­¾å
        uint256 deadline = block.timestamp + 1 hours;
        (uint8 v, bytes32 r, bytes32 s) = createPermitSignature(
            user1,
            address(market),
            0.5 ether, // æŠ˜æ‰£ä»·æ ¼
            deadline,
            user1PrivateKey
        );
        
        // 2. é¢„ä»˜æ¬¾
        market.permitPrePay(0.5 ether, deadline, v, r, s);
        
        // 3. è´­ä¹° NFT
        market.claimNFT(1, user1Proof);
        
        // éªŒè¯ç»“æœ
        assertEq(nft.ownerOf(1), user1);
        assertEq(market.hasClaimed(user1), true);
        
        vm.stopPrank();
    }
    
    function testNonWhitelistUserPaysFullPrice() public {
        vm.startPrank(user2);
        
        // 1. ä¼ ç»Ÿæˆæƒæ–¹å¼
        token.approve(address(market), 1 ether);
        token.transferFrom(user2, address(market), 1 ether);
        
        // æ‰‹åŠ¨æ›´æ–°é¢„ä»˜æ¬¾ï¼ˆåœ¨å®é™…åˆçº¦ä¸­éœ€è¦ä¸åŒçš„å®ç°ï¼‰
        // è¿™é‡Œç®€åŒ–å¤„ç†
        
        // 2. è´­ä¹° NFTï¼ˆç©ºè¯æ˜ï¼‰
        bytes32[] memory emptyProof;
        market.claimNFT(1, emptyProof);
        
        // éªŒè¯ç»“æœ
        assertEq(nft.ownerOf(1), user2);
        
        vm.stopPrank();
    }
    
    function createPermitSignature(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 privateKey
    ) internal view returns (uint8 v, bytes32 r, bytes32 s) {
        // å®ç° permit ç­¾åé€»è¾‘
        // ... ç­¾åä»£ç 
    }
}
```

### 7.2 é›†æˆæµ‹è¯•

```javascript
// å®Œæ•´æµç¨‹æµ‹è¯•
async function integrationTest() {
    console.log("ğŸ§ª å¼€å§‹é›†æˆæµ‹è¯•...");
    
    // 1. éƒ¨ç½²åˆçº¦
    console.log("1. éƒ¨ç½²åˆçº¦...");
    const contracts = await deployContracts();
    
    // 2. è®¾ç½®åˆå§‹çŠ¶æ€
    console.log("2. è®¾ç½®åˆå§‹çŠ¶æ€...");
    await setupInitialState(contracts);
    
    // 3. æµ‹è¯•ç™½åå•ç”¨æˆ·è´­ä¹°
    console.log("3. æµ‹è¯•ç™½åå•ç”¨æˆ·è´­ä¹°...");
    await testWhitelistPurchase(contracts);
    
    // 4. æµ‹è¯•éç™½åå•ç”¨æˆ·è´­ä¹°
    console.log("4. æµ‹è¯•éç™½åå•ç”¨æˆ·è´­ä¹°...");
    await testRegularPurchase(contracts);
    
    // 5. æµ‹è¯•ç®¡ç†åŠŸèƒ½
    console.log("5. æµ‹è¯•ç®¡ç†åŠŸèƒ½...");
    await testAdminFunctions(contracts);
    
    console.log("âœ… é›†æˆæµ‹è¯•å®Œæˆï¼");
}

integrationTest().catch(console.error);
```

---

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### åœºæ™¯ 1ï¼šæ¸¸æˆé“å…·ç©ºæŠ•

```javascript
// æ¸¸æˆå…¬å¸ä¸ºç©å®¶ç©ºæŠ•é™é‡æ­¦å™¨
const gameItemAirdrop = {
    // ç™½åå•ï¼šæ´»è·ƒç©å®¶
    whitelist: getActivePlayers(),
    
    // NFTï¼šæ¸¸æˆæ­¦å™¨
    items: [
        { name: "ä¼ è¯´ä¹‹å‰‘", rarity: "legendary", price: "10 GAME" },
        { name: "é­”æ³•æ³•æ–", rarity: "epic", price: "5 GAME" },
        { name: "é’¢é“ç›¾ç‰Œ", rarity: "rare", price: "2 GAME" }
    ],
    
    // æŠ˜æ‰£ï¼šVIP ç©å®¶ 50% æŠ˜æ‰£
    discount: 50
};
```

### åœºæ™¯ 2ï¼šè‰ºæœ¯å“æ”¶è—ç©ºæŠ•

```javascript
// è‰ºæœ¯å®¶ä¸ºæ”¶è—å®¶ç©ºæŠ•æ•°å­—è‰ºæœ¯å“
const artCollectionAirdrop = {
    // ç™½åå•ï¼šæ—©æœŸæ”¶è—å®¶
    whitelist: getEarlyCollectors(),
    
    // NFTï¼šæ•°å­—è‰ºæœ¯å“
    artworks: [
        { title: "æ•°å­—æ¢¦å¢ƒ", artist: "CryptoArtist", price: "1 ETH" },
        { title: "åƒç´ å®‡å®™", artist: "PixelMaster", price: "0.5 ETH" },
        { title: "æŠ½è±¡æœªæ¥", artist: "AbstractVision", price: "2 ETH" }
    ],
    
    // æŠ˜æ‰£ï¼šæ”¶è—å®¶ä¸“äº«
    discount: 30
};
```

### åœºæ™¯ 3ï¼šä¼šå‘˜åˆ¶å•†åº—

```javascript
// å“ç‰Œä¸ºä¼šå‘˜æä¾›ä¸“å±å•†å“
const membershipStore = {
    // ç™½åå•ï¼šä¼šå‘˜ç”¨æˆ·
    whitelist: getMemberAddresses(),
    
    // NFTï¼šä¸“å±å•†å“
    products: [
        { name: "é™é‡ç‰ˆ Tæ¤", category: "fashion", price: "50 BRAND" },
        { name: "çºªå¿µå¾½ç« ", category: "collectible", price: "20 BRAND" },
        { name: "VIP é€šè¡Œè¯", category: "access", price: "100 BRAND" }
    ],
    
    // æŠ˜æ‰£ï¼šä¼šå‘˜ä¸“äº«
    discount: 25
};
```

---

## ğŸ”§ æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è§é”™è¯¯åŠè§£å†³æ–¹æ¡ˆ

#### 1. "Invalid proof" é”™è¯¯

```javascript
// é—®é¢˜ï¼šMerkle è¯æ˜éªŒè¯å¤±è´¥
// åŸå› ï¼šè¯æ˜è·¯å¾„ä¸æ­£ç¡®æˆ–ç”¨æˆ·ä¸åœ¨ç™½åå•ä¸­

// è§£å†³æ–¹æ¡ˆï¼š
function debugMerkleProof(userAddress, proof, merkleRoot) {
    const leaf = keccak256(userAddress);
    const isValid = MerkleTree.verify(proof, merkleRoot, leaf);
    
    console.log(`User: ${userAddress}`);
    console.log(`Leaf: ${leaf}`);
    console.log(`Proof: ${proof}`);
    console.log(`Root: ${merkleRoot}`);
    console.log(`Valid: ${isValid}`);
    
    if (!isValid) {
        console.log("âŒ ç”¨æˆ·ä¸åœ¨ç™½åå•ä¸­æˆ–è¯æ˜è·¯å¾„é”™è¯¯");
        // é‡æ–°ç”Ÿæˆè¯æ˜æˆ–æ£€æŸ¥ç™½åå•
    }
}
```

#### 2. "Already claimed" é”™è¯¯

```javascript
// é—®é¢˜ï¼šç”¨æˆ·å·²ç»é¢†å–è¿‡ NFT
// è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥ç”¨æˆ·çŠ¶æ€

async function checkUserStatus(userAddress) {
    const hasClaimed = await market.hasClaimed(userAddress);
    const prepaidAmount = await market.getUserPrepaidAmount(userAddress);
    
    console.log(`User ${userAddress}:`);
    console.log(`- Has claimed: ${hasClaimed}`);
    console.log(`- Prepaid amount: ${ethers.utils.formatEther(prepaidAmount)} tokens`);
    
    if (hasClaimed) {
        console.log("âŒ ç”¨æˆ·å·²ç»é¢†å–è¿‡ï¼Œæ— æ³•å†æ¬¡é¢†å–");
    }
}
```

#### 3. "Insufficient prepaid amount" é”™è¯¯

```javascript
// é—®é¢˜ï¼šé¢„ä»˜æ¬¾ä¸è¶³
// è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥ä½™é¢å’Œé¢„ä»˜æ¬¾

async function checkBalances(userAddress, requiredAmount) {
    const tokenBalance = await token.balanceOf(userAddress);
    const prepaidAmount = await market.getUserPrepaidAmount(userAddress);
    
    console.log(`Required: ${ethers.utils.formatEther(requiredAmount)}`);
    console.log(`Token balance: ${ethers.utils.formatEther(tokenBalance)}`);
    console.log(`Prepaid amount: ${ethers.utils.formatEther(prepaidAmount)}`);
    
    if (prepaidAmount.lt(requiredAmount)) {
        const needed = requiredAmount.sub(prepaidAmount);
        console.log(`âŒ éœ€è¦é¢å¤–é¢„ä»˜ ${ethers.utils.formatEther(needed)} tokens`);
    }
}
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. Gas ä¼˜åŒ–

```solidity
// ä¼˜åŒ–å‰ï¼šå¤šæ¬¡å­˜å‚¨å†™å…¥
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external {
    hasClaimed[msg.sender] = true;           // å†™å…¥ 1
    prepaidAmounts[msg.sender] -= price;     // å†™å…¥ 2
    // ... å…¶ä»–æ“ä½œ
}

// ä¼˜åŒ–åï¼šæ‰¹é‡æ›´æ–°
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external {
    // å…ˆè®¡ç®—æ‰€æœ‰å€¼ï¼Œç„¶åä¸€æ¬¡æ€§æ›´æ–°
    uint256 newPrepaidAmount = prepaidAmounts[msg.sender] - price;
    
    hasClaimed[msg.sender] = true;
    prepaidAmounts[msg.sender] = newPrepaidAmount;
}
```

### 2. å‰ç«¯ä¼˜åŒ–

```javascript
// ä½¿ç”¨ç¼“å­˜å‡å°‘ RPC è°ƒç”¨
class ContractCache {
    constructor() {
        this.cache = new Map();
        this.ttl = 60000; // 1åˆ†é’Ÿç¼“å­˜
    }
    
    async get(key, fetcher) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            return cached.value;
        }
        
        const value = await fetcher();
        this.cache.set(key, { value, timestamp: Date.now() });
        return value;
    }
}

const cache = new ContractCache();

// ç¼“å­˜ NFT ä»·æ ¼æŸ¥è¯¢
async function getNFTPrice(tokenId) {
    return cache.get(`price_${tokenId}`, async () => {
        return await nft.tokenPrices(tokenId);
    });
}
```

---

## ğŸ“ å­¦ä¹ æ€»ç»“

é€šè¿‡è¿™ä¸ªå®æˆ˜æ¼”ç»ƒï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š

âœ… **å®Œæ•´çš„é¡¹ç›®å¼€å‘æµç¨‹**ï¼šä»éœ€æ±‚åˆ†æåˆ°éƒ¨ç½²ä¸Šçº¿
âœ… **Merkle æ ‘çš„å®é™…åº”ç”¨**ï¼šç™½åå•éªŒè¯å’Œ gas ä¼˜åŒ–
âœ… **Permit æœºåˆ¶çš„ä½¿ç”¨**ï¼šæå‡ç”¨æˆ·ä½“éªŒ
âœ… **Multicall çš„å®ç°**ï¼šæ‰¹é‡æ“ä½œå’ŒåŸå­æ€§
âœ… **äº‹ä»¶ç›‘å¬å’ŒçŠ¶æ€ç®¡ç†**ï¼šå®æ—¶æ•°æ®æ›´æ–°
âœ… **é”™è¯¯å¤„ç†å’Œè°ƒè¯•æŠ€å·§**ï¼šå¿«é€Ÿå®šä½é—®é¢˜
âœ… **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**ï¼šé™ä½æˆæœ¬æå‡æ•ˆç‡

### ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. **æ·±å…¥å­¦ä¹  DeFi åè®®**ï¼šUniswapã€Compoundã€Aave
2. **æŒæ¡è·¨é“¾æŠ€æœ¯**ï¼šLayer 2ã€æ¡¥æ¥åè®®
3. **å­¦ä¹ å‰ç«¯é›†æˆ**ï¼šReact + Web3.js/Ethers.js
4. **äº†è§£å®‰å…¨å®¡è®¡**ï¼šå¸¸è§æ¼æ´å’Œé˜²æŠ¤æªæ–½
5. **å‚ä¸å¼€æºé¡¹ç›®**ï¼šè´¡çŒ®ä»£ç ï¼Œç§¯ç´¯ç»éªŒ

è®°ä½ï¼š**å®è·µæ˜¯æœ€å¥½çš„è€å¸ˆï¼Œä¸æ–­åŠ¨æ‰‹æ‰èƒ½çœŸæ­£æŒæ¡ Web3 å¼€å‘ï¼** ğŸš€