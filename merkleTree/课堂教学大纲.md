# 🎓 AirdropMerkleNFTMarket 课堂教学大纲

> 专为 Web3 初学者设计的完整课程体系

---

## 📋 课程信息

- **课程名称**：基于 Merkle 树的 NFT 空投市场开发
- **目标学员**：Web3 初学者、智能合约开发新手
- **课程时长**：6 小时（可分为 3 次课，每次 2 小时）
- **先修要求**：基础的编程经验，了解区块链概念
- **开发环境**：Foundry、VS Code、Git

---

## 🎯 课程目标

### 知识目标
- 理解 ERC20 和 ERC721 标准
- 掌握 Merkle 树在区块链中的应用
- 学会使用 Permit 机制优化用户体验
- 了解智能合约安全最佳实践

### 技能目标
- 能够编写和部署智能合约
- 掌握 Foundry 开发工具链
- 学会编写完整的测试用例
- 能够进行合约交互和前端集成

### 素养目标
- 培养安全编程意识
- 建立系统性思维
- 提升问题解决能力

---

## 📚 第一课：项目概览与基础概念（2小时）

### 🕐 时间安排

| 时间段 | 内容 | 教学方式 |
|--------|------|----------|
| 0-20分钟 | 课程介绍与环境准备 | 讲解 + 演示 |
| 20-50分钟 | Web3 基础概念回顾 | 讲解 + 互动 |
| 50-60分钟 | 休息 | - |
| 60-90分钟 | 项目架构解析 | 讲解 + 案例 |
| 90-120分钟 | 开发环境搭建 | 实操 + 指导 |

### 📖 教学内容

#### 1. 课程导入（20分钟）

**开场白**：
> "大家好！今天我们要一起构建一个完整的 Web3 项目。想象一下，你是一个 NFT 项目方，要为早期支持者举办空投活动。传统方式需要维护一个庞大的白名单，成本高昂。我们的项目将用 Merkle 树技术解决这个问题！"

**学习目标展示**：
```
今天学完后，你将能够：
✅ 理解什么是 Merkle 树及其优势
✅ 掌握 ERC20 和 ERC721 标准
✅ 学会使用 Foundry 开发工具
✅ 编写第一个智能合约
```

#### 2. 基础概念回顾（30分钟）

**互动问答**：
- "谁能告诉我什么是智能合约？"
- "ERC20 和 ERC721 有什么区别？"
- "为什么需要 gas 费？"

**核心概念讲解**：

```solidity
// ERC20 示例：代币就像数字货币
contract SimpleToken {
    mapping(address => uint256) public balances;
    
    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}

// ERC721 示例：NFT 就像数字收藏品
contract SimpleNFT {
    mapping(uint256 => address) public owners;
    
    function mint(address to, uint256 tokenId) public {
        owners[tokenId] = to;
    }
}
```

**比喻解释**：
- ERC20 = 银行账户（可分割的数字货币）
- ERC721 = 房产证（独一无二的数字资产）

#### 3. 项目架构解析（30分钟）

**架构图展示**：
```
🏪 数字商店系统
├── 💰 AirdropToken（商店货币）
├── 🖼️ AirdropNFT（商店商品）
└── 🧠 AirdropMerkleNFTMarket（商店大脑）
```

**实际案例**：
> "假设你要开一家数字艺术品商店。顾客用你发行的代币购买 NFT 艺术品。VIP 会员享受折扣，但你不想把所有会员信息都存在区块链上（太贵了！）。这时候 Merkle 树就派上用场了。"

#### 4. 环境搭建实操（30分钟）

**步骤演示**：
```bash
# 1. 安装 Foundry
curl -L https://foundry.paradigm.xyz | bash
foundryup

# 2. 创建项目
forge init my-nft-market
cd my-nft-market

# 3. 安装依赖
forge install OpenZeppelin/openzeppelin-contracts

# 4. 编译测试
forge build
forge test
```

**常见问题处理**：
- Windows 用户安装问题
- 网络连接问题
- 权限问题

### 🎯 课堂活动

#### 活动1：概念配对游戏（10分钟）
学生将概念和解释进行配对：
- Merkle 树 ↔ 高效验证大量数据
- Permit ↔ 免 gas 授权机制
- Multicall ↔ 批量操作功能

#### 活动2：架构设计讨论（15分钟）
分组讨论：如果要设计一个游戏道具交易市场，需要哪些组件？

### 📝 课后作业
1. 完成开发环境搭建
2. 阅读《教学文档-初学者指南.md》
3. 思考：你想用这个技术解决什么实际问题？

---

## 🔧 第二课：智能合约开发实战（2小时）

### 🕐 时间安排

| 时间段 | 内容 | 教学方式 |
|--------|------|----------|
| 0-30分钟 | 代码结构分析 | 讲解 + 演示 |
| 30-60分钟 | AirdropToken 合约开发 | 编码 + 指导 |
| 60-70分钟 | 休息 | - |
| 70-100分钟 | AirdropNFT 合约开发 | 编码 + 指导 |
| 100-120分钟 | 编译测试与问题解决 | 实操 + 答疑 |

### 📖 教学内容

#### 1. 代码结构分析（30分钟）

**文件结构讲解**：
```
src/
├── AirdropToken.sol      // 代币合约
├── AirdropNFT.sol        // NFT 合约
└── AirdropMerkleNFTMarket.sol  // 主合约

test/
└── AirdropMerkleNFTMarket.t.sol  // 测试文件
```

**导入语句解释**：
```solidity
// 为什么要导入这些？
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// ↑ 提供标准的代币功能

import "@openzeppelin/contracts/access/Ownable.sol";
// ↑ 提供权限控制功能
```

#### 2. AirdropToken 合约开发（30分钟）

**逐步构建**：

```solidity
// 第一步：基础结构
contract AirdropToken is ERC20, ERC20Permit, Ownable {
    // 学生思考：为什么继承这三个合约？
}

// 第二步：构造函数
constructor(
    string memory name,
    string memory symbol,
    address initialOwner
) ERC20(name, symbol) ERC20Permit(name) Ownable(initialOwner) {
    // 学生思考：每个参数的作用是什么？
}

// 第三步：核心功能
function mint(address to, uint256 amount) external onlyOwner {
    _mint(to, amount);
    // 学生思考：为什么需要 onlyOwner 修饰符？
}
```

**边写边问**：
- "为什么要继承 ERC20Permit？"
- "onlyOwner 修饰符有什么作用？"
- "mint 函数可能被恶意利用吗？"

#### 3. AirdropNFT 合约开发（30分钟）

**重点功能讲解**：

```solidity
// 状态变量设计
uint256 private _tokenIdCounter;  // 为什么用 private？
mapping(uint256 => uint256) public tokenPrices;  // 为什么用 public？

// 铸造功能
function mint(address to, string memory tokenURI) external onlyOwner returns (uint256) {
    _tokenIdCounter++;  // 为什么先加再用？
    uint256 tokenId = _tokenIdCounter;
    _mint(to, tokenId);
    _setTokenURI(tokenId, tokenURI);
    return tokenId;  // 为什么要返回 tokenId？
}
```

**安全考虑**：
- 整数溢出问题（Solidity 0.8+ 自动检查）
- 权限控制的重要性
- 输入验证的必要性

#### 4. 编译测试（20分钟）

**实时演示**：
```bash
# 编译合约
forge build

# 如果有错误，一起分析解决
# 常见错误：
# - 导入路径错误
# - 语法错误
# - 版本不兼容
```

### 🎯 课堂活动

#### 活动1：代码审查（15分钟）
学生互相检查代码，找出潜在问题：
- 是否有安全漏洞？
- 代码逻辑是否正确？
- 命名是否规范？

#### 活动2：功能扩展讨论（10分钟）
讨论：如何为 NFT 添加稀有度属性？

### 📝 课后作业
1. 完成 AirdropToken 和 AirdropNFT 合约
2. 阅读《合约代码详解.md》
3. 尝试添加一个新功能（如批量铸造）

---

## 🌳 第三课：Merkle 树与高级功能（2小时）

### 🕐 时间安排

| 时间段 | 内容 | 教学方式 |
|--------|------|----------|
| 0-30分钟 | Merkle 树原理深入 | 讲解 + 演示 |
| 30-60分钟 | 主合约核心功能开发 | 编码 + 指导 |
| 60-70分钟 | 休息 | - |
| 70-100分钟 | Permit 与 Multicall 实现 | 编码 + 指导 |
| 100-120分钟 | 完整测试与部署 | 实操 + 演示 |

### 📖 教学内容

#### 1. Merkle 树原理深入（30分钟）

**可视化演示**：
```
白名单验证问题：
❌ 传统方式：存储 1000 个地址 = $1000+ gas
✅ Merkle 树：存储 1 个根哈希 = $5 gas

        Root
       /    \
   Hash12   Hash34
   /  \     /   \
  H1   H2  H3   H4
  |    |   |    |
 地址A 地址B 地址C 地址D
```

**JavaScript 演示**：
```javascript
// 现场演示 Merkle 树构建
const { MerkleTree } = require('merkletreejs');
const keccak256 = require('keccak256');

const addresses = ['0x1111...', '0x2222...', '0x3333...', '0x4444...'];
const leaves = addresses.map(addr => keccak256(addr));
const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });

console.log('Root:', tree.getHexRoot());
console.log('Proof for 0x1111...:', tree.getHexProof(keccak256('0x1111...')));
```

#### 2. 主合约核心功能（30分钟）

**白名单验证**：
```solidity
function verifyWhitelist(address user, bytes32[] calldata proof) public view returns (bool) {
    bytes32 leaf = keccak256(abi.encodePacked(user));
    return MerkleProof.verify(proof, merkleRoot, leaf);
    // 学生思考：为什么要用 keccak256(abi.encodePacked(user))？
}
```

**价格计算**：
```solidity
function calculateDiscountedPrice(uint256 originalPrice) public pure returns (uint256) {
    return (originalPrice * DISCOUNT_RATE) / 100;
    // 学生思考：为什么用乘法再除法，而不是直接乘以 0.5？
}
```

**核心购买逻辑**：
```solidity
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external nonReentrant {
    // 逐步构建，每一步都解释原因
    require(nft.tokenListed(tokenId), "Token not listed");
    require(!hasClaimed[msg.sender], "Already claimed");
    
    uint256 originalPrice = nft.tokenPrices(tokenId);
    uint256 finalPrice;
    
    if (verifyWhitelist(msg.sender, proof)) {
        finalPrice = calculateDiscountedPrice(originalPrice);
    } else {
        finalPrice = originalPrice;
    }
    
    // ... 继续实现
}
```

#### 3. Permit 与 Multicall（30分钟）

**Permit 机制讲解**：
```solidity
// 传统方式：2 笔交易
// 1. approve(spender, amount)
// 2. transferFrom(owner, spender, amount)

// Permit 方式：1 笔交易
// permit(owner, spender, amount, deadline, v, r, s) + transferFrom
```

**Multicall 实现**：
```solidity
function multicall(bytes[] calldata data) external returns (bytes[] memory results) {
    results = new bytes[](data.length);
    
    for (uint256 i = 0; i < data.length; i++) {
        (bool success, bytes memory result) = address(this).delegatecall(data[i]);
        require(success, "Multicall failed");
        results[i] = result;
    }
}
// 学生思考：为什么用 delegatecall 而不是 call？
```

#### 4. 完整测试与部署（20分钟）

**测试演示**：
```bash
# 运行测试
forge test -vv

# 如果测试失败，一起分析原因
# 常见问题：
# - 签名验证失败
# - 权限问题
# - 逻辑错误
```

**部署演示**：
```bash
# 本地部署测试
forge script script/Deploy.s.sol

# 解释部署输出
# 展示合约地址
# 验证部署成功
```

### 🎯 课堂活动

#### 活动1：Merkle 证明验证（15分钟）
给定一个 Merkle 树，学生手动计算证明路径

#### 活动2：安全漏洞发现（15分钟）
展示一段有漏洞的代码，学生找出问题

### 📝 课后作业
1. 完成所有合约开发
2. 阅读《实战演练指南.md》
3. 尝试部署到测试网络

---

## 🎯 教学方法与技巧

### 1. 互动式教学

**提问技巧**：
- 开放性问题："你觉得这样设计有什么好处？"
- 引导性问题："如果不加这个检查会怎样？"
- 对比性问题："这两种方法哪个更好？为什么？"

**学生参与**：
- 让学生预测代码执行结果
- 鼓励学生提出改进建议
- 组织小组讨论和分享

### 2. 案例驱动教学

**真实案例**：
- OpenSea 的 NFT 交易
- Uniswap 的代币交换
- ENS 的域名拍卖

**类比解释**：
- 智能合约 = 自动售货机
- Gas 费 = 邮费
- 私钥 = 银行卡密码

### 3. 渐进式难度

**知识点递进**：
```
基础概念 → 简单合约 → 复杂逻辑 → 安全考虑 → 优化技巧
```

**代码复杂度递进**：
```
Hello World → ERC20 → ERC721 → 复合合约 → 高级特性
```

---

## 📊 评估方式

### 1. 过程性评估（60%）

**课堂参与（20%）**：
- 积极回答问题
- 主动提出疑问
- 参与小组讨论

**作业完成（40%）**：
- 代码质量
- 功能完整性
- 创新性扩展

### 2. 结果性评估（40%）

**项目展示**：
- 合约功能演示
- 代码讲解
- 问题回答

**评分标准**：
```
优秀（90-100）：功能完整，代码规范，有创新
良好（80-89）：功能基本完整，代码较规范
及格（60-79）：基本功能实现，代码可运行
不及格（<60）：功能不完整或代码无法运行
```

---

## 🛠️ 教学资源

### 1. 必备工具
- **开发环境**：VS Code + Solidity 插件
- **区块链工具**：Foundry、Remix IDE
- **版本控制**：Git + GitHub
- **文档工具**：Markdown 编辑器

### 2. 参考资料
- [Solidity 官方文档](https://docs.soliditylang.org/)
- [OpenZeppelin 文档](https://docs.openzeppelin.com/)
- [Foundry 教程](https://book.getfoundry.sh/)
- [以太坊开发者资源](https://ethereum.org/developers/)

### 3. 在线资源
- **测试网络**：Sepolia、Goerli
- **区块浏览器**：Etherscan
- **代币水龙头**：获取测试 ETH
- **IPFS 网关**：存储 NFT 元数据

---

## 🚨 常见问题与解决方案

### 1. 技术问题

**编译错误**：
```bash
# 常见错误：版本不兼容
Error: Source file requires different compiler version

# 解决方案：检查 pragma 版本
pragma solidity ^0.8.25;
```

**测试失败**：
```bash
# 常见错误：签名验证失败
Error: ERC2612InvalidSigner

# 解决方案：检查私钥和地址对应关系
```

### 2. 概念理解问题

**Merkle 树理解困难**：
- 用"家谱树"类比
- 画图演示验证过程
- 提供在线可视化工具

**Gas 费概念模糊**：
- 用"邮费"类比
- 展示实际交易费用
- 解释优化的重要性

### 3. 实践操作问题

**环境搭建困难**：
- 提供详细安装指南
- 准备虚拟机镜像
- 安排助教一对一指导

**代码调试困难**：
- 教授调试技巧
- 提供常见错误列表
- 鼓励同学互助

---

## 📈 课程改进建议

### 1. 内容优化
- 根据学生反馈调整难度
- 增加更多实际案例
- 更新最新技术动态

### 2. 教学方式改进
- 增加动手实践时间
- 引入更多互动环节
- 利用现代化教学工具

### 3. 评估方式完善
- 增加同伴评议环节
- 引入项目展示评分
- 建立长期跟踪机制

---

## 🎉 课程总结

通过这门课程，学生将：

✅ **掌握核心技能**：智能合约开发、测试、部署
✅ **理解重要概念**：Merkle 树、Permit、Multicall
✅ **培养安全意识**：防范常见攻击，编写安全代码
✅ **建立系统思维**：从需求分析到产品上线的完整流程
✅ **获得实战经验**：完成一个完整的 Web3 项目

**寄语**：
> "Web3 的世界充满无限可能，希望这门课程能成为你探索区块链世界的起点。记住，最好的学习方式就是不断实践和创新。愿你在 Web3 的道路上越走越远！" 🚀

---

## 📞 联系方式

**讲师邮箱**：instructor@web3course.com
**课程群组**：Web3 学习交流群
**答疑时间**：每周三、五 19:00-21:00
**项目仓库**：https://github.com/web3course/airdrop-merkle-nft-market

**记住**：学习路上遇到问题很正常，重要的是保持好奇心和坚持不懈的精神！💪