# ğŸ“– æ™ºèƒ½åˆçº¦ä»£ç è¯¦è§£

> é€è¡Œè§£è¯»ä¸‰ä¸ªæ ¸å¿ƒåˆçº¦ï¼Œè®©ä½ å½»åº•ç†è§£æ¯ä¸€è¡Œä»£ç çš„ä½œç”¨

---

## ğŸ—ï¸ åˆçº¦æ¦‚è§ˆ

é¡¹ç›®åŒ…å«ä¸‰ä¸ªæ™ºèƒ½åˆçº¦ï¼Œå°±åƒæ­ç§¯æœ¨ä¸€æ ·ï¼š

```
ğŸª AirdropMerkleNFTMarket (ä¸»åˆçº¦ - å•†åº—å¤§è„‘)
â”œâ”€â”€ ğŸ’° AirdropToken (ä»£å¸åˆçº¦ - å•†åº—è´§å¸)
â””â”€â”€ ğŸ–¼ï¸ AirdropNFT (NFTåˆçº¦ - å•†åº—å•†å“)
```

---

## ğŸ’° AirdropToken.sol - ä»£å¸åˆçº¦è¯¦è§£

### ğŸ“‹ åˆçº¦ç»“æ„

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
```

**è¿™äº›å¯¼å…¥æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ**
- `ERC20`ï¼šåŸºç¡€ä»£å¸åŠŸèƒ½ï¼ˆè½¬è´¦ã€ä½™é¢æŸ¥è¯¢ç­‰ï¼‰
- `ERC20Permit`ï¼šç­¾åæˆæƒåŠŸèƒ½ï¼ˆå… gas æˆæƒï¼‰
- `Ownable`ï¼šæ‰€æœ‰è€…æƒé™æ§åˆ¶

### ğŸ—ï¸ åˆçº¦å®šä¹‰

```solidity
contract AirdropToken is ERC20, ERC20Permit, Ownable {
    constructor(
        string memory name,
        string memory symbol,
        address initialOwner
    ) ERC20(name, symbol) ERC20Permit(name) Ownable(initialOwner) {}
```

**é€šä¿—è§£é‡Š**ï¼š
- è¿™å°±åƒå¼€ä¸€å®¶é“¶è¡Œï¼Œå‘è¡Œè‡ªå·±çš„è´§å¸
- `name`ï¼šè´§å¸åç§°ï¼ˆæ¯”å¦‚"ç©ºæŠ•å¸"ï¼‰
- `symbol`ï¼šè´§å¸ç¬¦å·ï¼ˆæ¯”å¦‚"AIRDROP"ï¼‰
- `initialOwner`ï¼šé“¶è¡Œè¡Œé•¿ï¼ˆæœ‰ç‰¹æ®Šæƒé™ï¼‰

### ğŸ’ æ ¸å¿ƒåŠŸèƒ½å‡½æ•°

#### 1. é“¸é€ ä»£å¸ï¼ˆå°é’ç¥¨ï¼‰

```solidity
function mint(address to, uint256 amount) external onlyOwner {
    _mint(to, amount);
}
```

**ä½œç”¨**ï¼šåˆ›é€ æ–°çš„ä»£å¸
**æ¯”å–»**ï¼šå°±åƒå¤®è¡Œå°é’ç¥¨
**æƒé™**ï¼šåªæœ‰åˆçº¦æ‰€æœ‰è€…å¯ä»¥è°ƒç”¨
**å‚æ•°**ï¼š
- `to`ï¼šç»™è°å‘ä»£å¸
- `amount`ï¼šå‘å¤šå°‘ä»£å¸

#### 2. é”€æ¯ä»£å¸ï¼ˆé”€æ¯é’ç¥¨ï¼‰

```solidity
function burn(uint256 amount) external {
    _burn(msg.sender, amount);
}
```

**ä½œç”¨**ï¼šé”€æ¯è‡ªå·±çš„ä»£å¸
**æ¯”å–»**ï¼šæŠŠé’ç¥¨çƒ§æ‰ï¼Œå‡å°‘æµé€šé‡
**æƒé™**ï¼šä»»ä½•äººéƒ½å¯ä»¥é”€æ¯è‡ªå·±çš„ä»£å¸
**å‚æ•°**ï¼š
- `amount`ï¼šè¦é”€æ¯çš„æ•°é‡

### ğŸ” Permit åŠŸèƒ½è¯¦è§£

**ä¼ ç»Ÿæˆæƒæµç¨‹**ï¼š
1. ç”¨æˆ·è°ƒç”¨ `approve(spender, amount)` - èŠ±è´¹ gas
2. å•†åº—è°ƒç”¨ `transferFrom(user, shop, amount)` - èŠ±è´¹ gas

**Permit æˆæƒæµç¨‹**ï¼š
1. ç”¨æˆ·åœ¨é“¾ä¸‹ç­¾å - ä¸èŠ±è´¹ gas
2. å•†åº—è°ƒç”¨ `permit()` + `transferFrom()` - åªèŠ±è´¹ä¸€æ¬¡ gas

```solidity
// è¿™ä¸ªå‡½æ•°ç»§æ‰¿è‡ª ERC20Permitï¼Œä¸éœ€è¦æˆ‘ä»¬å®ç°
function permit(
    address owner,      // ä»£å¸æ‰€æœ‰è€…
    address spender,    // è¢«æˆæƒè€…
    uint256 value,      // æˆæƒé‡‘é¢
    uint256 deadline,   // æˆæƒæˆªæ­¢æ—¶é—´
    uint8 v,           // ç­¾åå‚æ•°
    bytes32 r,         // ç­¾åå‚æ•°
    bytes32 s          // ç­¾åå‚æ•°
) external;
```

---

## ğŸ–¼ï¸ AirdropNFT.sol - NFTåˆçº¦è¯¦è§£

### ğŸ“‹ åˆçº¦ç»“æ„

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
```

**å¯¼å…¥è¯´æ˜**ï¼š
- `ERC721`ï¼šNFT æ ‡å‡†å®ç°
- `Ownable`ï¼šæƒé™æ§åˆ¶

### ğŸ—ï¸ åˆçº¦å®šä¹‰å’ŒçŠ¶æ€å˜é‡

```solidity
contract AirdropNFT is ERC721, Ownable {
    uint256 private _tokenIdCounter;
    
    // NFT å¸‚åœºç›¸å…³
    mapping(uint256 => uint256) public tokenPrices;
    mapping(uint256 => bool) public tokenListed;
    
    // äº‹ä»¶å®šä¹‰
    event TokenListed(uint256 indexed tokenId, uint256 price);
    event TokenUnlisted(uint256 indexed tokenId);
    event TokenPriceUpdated(uint256 indexed tokenId, uint256 newPrice);
```

**çŠ¶æ€å˜é‡è§£é‡Š**ï¼š
- `_tokenIdCounter`ï¼šNFT ç¼–å·è®¡æ•°å™¨ï¼ˆä» 1 å¼€å§‹ï¼‰
- `tokenPrices`ï¼šæ¯ä¸ª NFT çš„ä»·æ ¼
- `tokenListed`ï¼šNFT æ˜¯å¦åœ¨å”®

**äº‹ä»¶è§£é‡Š**ï¼š
- äº‹ä»¶å°±åƒ"å¹¿æ’­"ï¼Œå‘Šè¯‰å¤–ç•Œå‘ç”Ÿäº†ä»€ä¹ˆ
- å‰ç«¯å¯ä»¥ç›‘å¬è¿™äº›äº‹ä»¶æ¥æ›´æ–°ç•Œé¢

### ğŸ¨ NFT é“¸é€ åŠŸèƒ½

```solidity
function mint(address to, string memory tokenURI) external onlyOwner returns (uint256) {
    _tokenIdCounter++;
    uint256 tokenId = _tokenIdCounter;
    _mint(to, tokenId);
    _setTokenURI(tokenId, tokenURI);
    return tokenId;
}
```

**é€è¡Œè§£é‡Š**ï¼š
1. `_tokenIdCounter++`ï¼šç¼–å·åŠ  1ï¼ˆç¬¬ä¸€ä¸ª NFT æ˜¯ #1ï¼‰
2. `uint256 tokenId = _tokenIdCounter`ï¼šè·å–å½“å‰ç¼–å·
3. `_mint(to, tokenId)`ï¼šåˆ›å»º NFT å¹¶åˆ†é…ç»™ `to`
4. `_setTokenURI(tokenId, tokenURI)`ï¼šè®¾ç½® NFT çš„å…ƒæ•°æ®é“¾æ¥
5. `return tokenId`ï¼šè¿”å›æ–°åˆ›å»ºçš„ NFT ç¼–å·

**æ¯”å–»**ï¼šå°±åƒå·¥å‚ç”Ÿäº§å•†å“ï¼Œæ¯ä¸ªå•†å“éƒ½æœ‰å”¯ä¸€çš„åºåˆ—å·

### ğŸª å¸‚åœºåŠŸèƒ½

#### 1. ä¸Šæ¶å•†å“

```solidity
function listToken(uint256 tokenId, uint256 price) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    require(price > 0, "Price must be greater than 0");
    
    tokenPrices[tokenId] = price;
    tokenListed[tokenId] = true;
    
    emit TokenListed(tokenId, price);
}
```

**é€è¡Œè§£é‡Š**ï¼š
1. `require(ownerOf(tokenId) == msg.sender, "Not the owner")`ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯ NFT ä¸»äºº
2. `require(price > 0, "Price must be greater than 0")`ï¼šæ£€æŸ¥ä»·æ ¼æ˜¯å¦æœ‰æ•ˆ
3. `tokenPrices[tokenId] = price`ï¼šè®¾ç½®ä»·æ ¼
4. `tokenListed[tokenId] = true`ï¼šæ ‡è®°ä¸ºåœ¨å”®
5. `emit TokenListed(tokenId, price)`ï¼šå‘å‡ºä¸Šæ¶äº‹ä»¶

#### 2. ä¸‹æ¶å•†å“

```solidity
function unlistToken(uint256 tokenId) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    
    tokenListed[tokenId] = false;
    tokenPrices[tokenId] = 0;
    
    emit TokenUnlisted(tokenId);
}
```

**ä½œç”¨**ï¼šNFT ä¸»äººå¯ä»¥ä¸‹æ¶è‡ªå·±çš„å•†å“

#### 3. æ›´æ–°ä»·æ ¼

```solidity
function updateTokenPrice(uint256 tokenId, uint256 newPrice) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    require(tokenListed[tokenId], "Token not listed");
    require(newPrice > 0, "Price must be greater than 0");
    
    tokenPrices[tokenId] = newPrice;
    
    emit TokenPriceUpdated(tokenId, newPrice);
}
```

**ä½œç”¨**ï¼šä¿®æ”¹å·²ä¸Šæ¶ NFT çš„ä»·æ ¼

### ğŸ“Š æŸ¥è¯¢åŠŸèƒ½

```solidity
function getCurrentTokenId() external view returns (uint256) {
    return _tokenIdCounter;
}

function batchMint(address to, string[] memory tokenURIs) external onlyOwner returns (uint256[] memory) {
    uint256[] memory tokenIds = new uint256[](tokenURIs.length);
    
    for (uint256 i = 0; i < tokenURIs.length; i++) {
        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;
        _mint(to, tokenId);
        _setTokenURI(tokenId, tokenURIs[i]);
        tokenIds[i] = tokenId;
    }
    
    return tokenIds;
}
```

**æ‰¹é‡é“¸é€ è§£é‡Š**ï¼š
- ä¸€æ¬¡æ€§åˆ›å»ºå¤šä¸ª NFT
- è¿”å›æ‰€æœ‰æ–°åˆ›å»ºçš„ NFT ç¼–å·
- æé«˜æ•ˆç‡ï¼ŒèŠ‚çœ gas

---

## ğŸª AirdropMerkleNFTMarket.sol - ä¸»åˆçº¦è¯¦è§£

### ğŸ“‹ åˆçº¦ç»“æ„å’Œå¯¼å…¥

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./AirdropToken.sol";
import "./AirdropNFT.sol";
```

**å¯¼å…¥è¯´æ˜**ï¼š
- `ReentrancyGuard`ï¼šé˜²æ­¢é‡å…¥æ”»å‡»
- `MerkleProof`ï¼šéªŒè¯ Merkle è¯æ˜
- `Ownable`ï¼šæƒé™æ§åˆ¶
- è‡ªå®šä¹‰åˆçº¦ï¼šä»£å¸å’Œ NFT åˆçº¦

### ğŸ—ï¸ çŠ¶æ€å˜é‡

```solidity
contract AirdropMerkleNFTMarket is ReentrancyGuard, Ownable {
    AirdropToken public immutable token;
    AirdropNFT public immutable nft;
    bytes32 public merkleRoot;
    uint256 public constant DISCOUNT_RATE = 50; // 50% æŠ˜æ‰£
    
    mapping(address => bool) public hasClaimed;
    mapping(address => uint256) public prepaidAmounts;
```

**å˜é‡è§£é‡Š**ï¼š
- `token`ï¼šä»£å¸åˆçº¦åœ°å€ï¼ˆä¸å¯å˜ï¼‰
- `nft`ï¼šNFT åˆçº¦åœ°å€ï¼ˆä¸å¯å˜ï¼‰
- `merkleRoot`ï¼šç™½åå•çš„ Merkle æ ¹å“ˆå¸Œ
- `DISCOUNT_RATE`ï¼šæŠ˜æ‰£ç‡ï¼ˆ50%ï¼‰
- `hasClaimed`ï¼šè®°å½•è°å·²ç»é¢†å–è¿‡
- `prepaidAmounts`ï¼šè®°å½•é¢„ä»˜æ¬¾é‡‘é¢

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½è¯¦è§£

#### 1. ç™½åå•éªŒè¯

```solidity
function verifyWhitelist(address user, bytes32[] calldata proof) public view returns (bool) {
    bytes32 leaf = keccak256(abi.encodePacked(user));
    return MerkleProof.verify(proof, merkleRoot, leaf);
}
```

**å·¥ä½œåŸç†**ï¼š
1. `keccak256(abi.encodePacked(user))`ï¼šæŠŠç”¨æˆ·åœ°å€è½¬æ¢æˆå¶å­èŠ‚ç‚¹
2. `MerkleProof.verify(proof, merkleRoot, leaf)`ï¼šéªŒè¯è¯æ˜è·¯å¾„
3. è¿”å› `true` è¡¨ç¤ºç”¨æˆ·åœ¨ç™½åå•ä¸­

**æ¯”å–»**ï¼šå°±åƒéªŒè¯å­¦ç”Ÿè¯ï¼Œæ£€æŸ¥å­¦å·æ˜¯å¦åœ¨å­¦æ ¡æ•°æ®åº“ä¸­

#### 2. è®¡ç®—æŠ˜æ‰£ä»·æ ¼

```solidity
function calculateDiscountedPrice(uint256 originalPrice) public pure returns (uint256) {
    return (originalPrice * DISCOUNT_RATE) / 100;
}
```

**ä½œç”¨**ï¼šç™½åå•ç”¨æˆ·äº«å— 50% æŠ˜æ‰£
**è®¡ç®—**ï¼šåŸä»· Ã— 50 Ã· 100 = æŠ˜æ‰£ä»·

#### 3. Permit é¢„ä»˜æ¬¾

```solidity
function permitPrePay(
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
) external {
    // ä½¿ç”¨ permit æˆæƒ
    token.permit(msg.sender, address(this), value, deadline, v, r, s);
    
    // è½¬ç§»ä»£å¸åˆ°åˆçº¦
    token.transferFrom(msg.sender, address(this), value);
    
    // è®°å½•é¢„ä»˜æ¬¾
    prepaidAmounts[msg.sender] += value;
    
    emit PrePaid(msg.sender, value);
}
```

**é€æ­¥è§£é‡Š**ï¼š
1. **permit æˆæƒ**ï¼šç”¨ç­¾åä»£æ›¿ä¼ ç»Ÿçš„ approve
2. **è½¬ç§»ä»£å¸**ï¼šæŠŠç”¨æˆ·çš„ä»£å¸è½¬åˆ°åˆçº¦ä¸­
3. **è®°å½•é¢„ä»˜æ¬¾**ï¼šè®°å½•ç”¨æˆ·é¢„ä»˜äº†å¤šå°‘é’±
4. **å‘å‡ºäº‹ä»¶**ï¼šé€šçŸ¥å¤–ç•Œé¢„ä»˜æ¬¾æˆåŠŸ

**æ¯”å–»**ï¼šå°±åƒå……å€¼ä¼šå‘˜å¡ï¼Œå…ˆæŠŠé’±å­˜åˆ°å¡é‡Œ

#### 4. é¢†å– NFTï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰

```solidity
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external nonReentrant {
    // æ£€æŸ¥ NFT æ˜¯å¦åœ¨å”®
    require(nft.tokenListed(tokenId), "Token not listed");
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»é¢†å–è¿‡
    require(!hasClaimed[msg.sender], "Already claimed");
    
    // è·å–åŸä»·
    uint256 originalPrice = nft.tokenPrices(tokenId);
    require(originalPrice > 0, "Invalid price");
    
    uint256 finalPrice;
    
    // éªŒè¯ç™½åå•å¹¶è®¡ç®—ä»·æ ¼
    if (verifyWhitelist(msg.sender, proof)) {
        finalPrice = calculateDiscountedPrice(originalPrice);
    } else {
        finalPrice = originalPrice;
    }
    
    // æ£€æŸ¥é¢„ä»˜æ¬¾æ˜¯å¦è¶³å¤Ÿ
    require(prepaidAmounts[msg.sender] >= finalPrice, "Insufficient prepaid amount");
    
    // æ‰£é™¤é¢„ä»˜æ¬¾
    prepaidAmounts[msg.sender] -= finalPrice;
    
    // æ ‡è®°å·²é¢†å–
    hasClaimed[msg.sender] = true;
    
    // è·å– NFT å½“å‰æ‰€æœ‰è€…
    address nftOwner = nft.ownerOf(tokenId);
    
    // è½¬ç§» NFT
    nft.transferFrom(nftOwner, msg.sender, tokenId);
    
    // æ”¯ä»˜ç»™ NFT æ‰€æœ‰è€…
    token.transfer(nftOwner, finalPrice);
    
    emit NFTClaimed(msg.sender, tokenId, finalPrice);
}
```

**è¯¦ç»†æµç¨‹è§£é‡Š**ï¼š

1. **å®‰å…¨æ£€æŸ¥**ï¼š
   - NFT å¿…é¡»åœ¨å”®
   - ç”¨æˆ·ä¸èƒ½é‡å¤é¢†å–
   - ä»·æ ¼å¿…é¡»æœ‰æ•ˆ

2. **ä»·æ ¼è®¡ç®—**ï¼š
   - éªŒè¯ Merkle è¯æ˜
   - ç™½åå•ç”¨æˆ·ï¼š50% æŠ˜æ‰£
   - éç™½åå•ç”¨æˆ·ï¼šåŸä»·

3. **æ”¯ä»˜å¤„ç†**ï¼š
   - æ£€æŸ¥é¢„ä»˜æ¬¾æ˜¯å¦è¶³å¤Ÿ
   - æ‰£é™¤ç›¸åº”é‡‘é¢
   - æ ‡è®°å·²é¢†å–çŠ¶æ€

4. **NFT è½¬ç§»**ï¼š
   - ä»åŸæ‰€æœ‰è€…è½¬ç§»ç»™è´­ä¹°è€…
   - æ”¯ä»˜ä»£å¸ç»™åŸæ‰€æœ‰è€…

#### 5. Multicall æ‰¹é‡æ“ä½œ

```solidity
function multicall(bytes[] calldata data) external returns (bytes[] memory results) {
    results = new bytes[](data.length);
    
    for (uint256 i = 0; i < data.length; i++) {
        (bool success, bytes memory result) = address(this).delegatecall(data[i]);
        
        if (!success) {
            // å¦‚æœè°ƒç”¨å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
            if (result.length < 68) revert("Multicall failed");
            assembly {
                result := add(result, 0x04)
            }
            revert(abi.decode(result, (string)));
        }
        
        results[i] = result;
    }
}
```

**å·¥ä½œåŸç†**ï¼š
1. **å¾ªç¯å¤„ç†**ï¼šéå†æ‰€æœ‰è¦æ‰§è¡Œçš„è°ƒç”¨
2. **delegatecall**ï¼šåœ¨å½“å‰åˆçº¦ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œè°ƒç”¨
3. **é”™è¯¯å¤„ç†**ï¼šå¦‚æœä»»ä½•ä¸€ä¸ªè°ƒç”¨å¤±è´¥ï¼Œæ•´ä¸ªäº¤æ˜“å›æ»š
4. **è¿”å›ç»“æœ**ï¼šæ”¶é›†æ‰€æœ‰è°ƒç”¨çš„è¿”å›å€¼

**ä½¿ç”¨åœºæ™¯**ï¼š
```solidity
// ä¸€æ¬¡äº¤æ˜“å®Œæˆï¼šé¢„ä»˜æ¬¾ + é¢†å– NFT
bytes[] memory calls = new bytes[](2);
calls[0] = abi.encodeWithSelector(this.permitPrePay.selector, amount, deadline, v, r, s);
calls[1] = abi.encodeWithSelector(this.claimNFT.selector, tokenId, proof);
this.multicall(calls);
```

### ğŸ”§ ç®¡ç†åŠŸèƒ½

#### 1. æ›´æ–° Merkle Root

```solidity
function updateMerkleRoot(bytes32 newMerkleRoot) external onlyOwner {
    merkleRoot = newMerkleRoot;
    emit MerkleRootUpdated(newMerkleRoot);
}
```

**ä½œç”¨**ï¼šç®¡ç†å‘˜å¯ä»¥æ›´æ–°ç™½åå•

#### 2. ç´§æ€¥æå–

```solidity
function emergencyWithdraw() external onlyOwner {
    uint256 balance = token.balanceOf(address(this));
    token.transfer(owner(), balance);
    emit EmergencyWithdraw(owner(), balance);
}
```

**ä½œç”¨**ï¼šç´§æ€¥æƒ…å†µä¸‹æå–åˆçº¦ä¸­çš„ä»£å¸

### ğŸ“Š æŸ¥è¯¢åŠŸèƒ½

```solidity
function getContractTokenBalance() external view returns (uint256) {
    return token.balanceOf(address(this));
}

function getUserPrepaidAmount(address user) external view returns (uint256) {
    return prepaidAmounts[user];
}

function hasUserClaimed(address user) external view returns (bool) {
    return hasClaimed[user];
}
```

**ä½œç”¨**ï¼šæä¾›å„ç§æŸ¥è¯¢æ¥å£ï¼Œæ–¹ä¾¿å‰ç«¯è°ƒç”¨

---

## ğŸ”’ å®‰å…¨æœºåˆ¶è¯¦è§£

### 1. é‡å…¥æ”»å‡»é˜²æŠ¤

```solidity
modifier nonReentrant() {
    require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
    _status = _ENTERED;
    _;
    _status = _NOT_ENTERED;
}
```

**å·¥ä½œåŸç†**ï¼š
- å‡½æ•°å¼€å§‹æ—¶è®¾ç½®çŠ¶æ€ä¸º"å·²è¿›å…¥"
- å¦‚æœå‡½æ•°è¿˜åœ¨æ‰§è¡Œæ—¶è¢«å†æ¬¡è°ƒç”¨ï¼Œä¼šè¢«æ‹’ç»
- å‡½æ•°ç»“æŸæ—¶é‡ç½®çŠ¶æ€

### 2. æƒé™æ§åˆ¶

```solidity
modifier onlyOwner() {
    require(owner() == msg.sender, "Ownable: caller is not the owner");
    _;
}
```

**ä½œç”¨**ï¼šç¡®ä¿åªæœ‰åˆçº¦æ‰€æœ‰è€…å¯ä»¥æ‰§è¡Œæ•æ„Ÿæ“ä½œ

### 3. è¾“å…¥éªŒè¯

```solidity
require(nft.tokenListed(tokenId), "Token not listed");
require(!hasClaimed[msg.sender], "Already claimed");
require(originalPrice > 0, "Invalid price");
```

**åŸåˆ™**ï¼šæ°¸è¿œä¸è¦ä¿¡ä»»ç”¨æˆ·è¾“å…¥ï¼Œå¿…é¡»éªŒè¯æ‰€æœ‰å‚æ•°

---

## ğŸ¯ å…³é”®è®¾è®¡æ¨¡å¼

### 1. å·¥å‚æ¨¡å¼

åˆçº¦åœ¨æ„é€ å‡½æ•°ä¸­æ¥æ”¶å…¶ä»–åˆçº¦çš„åœ°å€ï¼š

```solidity
constructor(
    address tokenAddress,
    address nftAddress,
    bytes32 initialMerkleRoot,
    address initialOwner
) Ownable(initialOwner) {
    token = AirdropToken(tokenAddress);
    nft = AirdropNFT(nftAddress);
    merkleRoot = initialMerkleRoot;
}
```

### 2. çŠ¶æ€æœºæ¨¡å¼

ç”¨æˆ·çŠ¶æ€çš„å˜åŒ–ï¼š
```
æœªé¢„ä»˜ â†’ å·²é¢„ä»˜ â†’ å·²é¢†å–
```

### 3. äº‹ä»¶é©±åŠ¨æ¨¡å¼

æ‰€æœ‰é‡è¦æ“ä½œéƒ½ä¼šå‘å‡ºäº‹ä»¶ï¼š
```solidity
event PrePaid(address indexed user, uint256 amount);
event NFTClaimed(address indexed user, uint256 indexed tokenId, uint256 price);
event MerkleRootUpdated(bytes32 newMerkleRoot);
```

---

## ğŸ’¡ ä¼˜åŒ–æŠ€å·§

### 1. Gas ä¼˜åŒ–

- ä½¿ç”¨ `immutable` å˜é‡å‡å°‘å­˜å‚¨è¯»å–
- æ‰¹é‡æ“ä½œå‡å°‘äº¤æ˜“æ¬¡æ•°
- åˆç†çš„æ•°æ®ç»“æ„è®¾è®¡

### 2. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

- Permit æœºåˆ¶å‡å°‘äº¤æ˜“æ­¥éª¤
- Multicall æ”¯æŒæ‰¹é‡æ“ä½œ
- è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯

### 3. å®‰å…¨ä¼˜åŒ–

- å®Œæ•´çš„è¾“å…¥éªŒè¯
- é‡å…¥æ”»å‡»é˜²æŠ¤
- æƒé™æ§åˆ¶

---

## ğŸ¤” å¸¸è§é—®é¢˜

### Q: ä¸ºä»€ä¹ˆè¦ç”¨ `immutable` ä¿®é¥°ç¬¦ï¼Ÿ

**A**: 
- `immutable` å˜é‡åœ¨éƒ¨ç½²æ—¶è®¾ç½®ï¼Œä¹‹åä¸èƒ½ä¿®æ”¹
- è¯»å– `immutable` å˜é‡æ¯”è¯»å–æ™®é€šçŠ¶æ€å˜é‡æ›´ä¾¿å®œ
- æä¾›äº†å®‰å…¨æ€§ä¿è¯

### Q: `delegatecall` å’Œ `call` æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**:
- `call`ï¼šåœ¨ç›®æ ‡åˆçº¦çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œ
- `delegatecall`ï¼šåœ¨å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œç›®æ ‡åˆçº¦çš„ä»£ç 
- Multicall ä½¿ç”¨ `delegatecall` ä¿æŒçŠ¶æ€ä¸€è‡´æ€§

### Q: ä¸ºä»€ä¹ˆè¦æ£€æŸ¥ `hasClaimed`ï¼Ÿ

**A**:
- é˜²æ­¢ç”¨æˆ·å¤šæ¬¡é¢†å–åŒä¸€ä¸ª NFT
- ç¡®ä¿æ¯ä¸ªç”¨æˆ·åªèƒ½äº«å—ä¸€æ¬¡æŠ˜æ‰£
- ç»´æŠ¤ç³»ç»Ÿçš„å…¬å¹³æ€§

---

## ğŸ“š å­¦ä¹ å»ºè®®

1. **é€è¡Œé˜…è¯»**ï¼šä¸è¦è·³è¿‡ä»»ä½•ä¸€è¡Œä»£ç 
2. **ç†è§£åŸç†**ï¼šçŸ¥é“ä¸ºä»€ä¹ˆè¿™æ ·å†™ï¼Œè€Œä¸åªæ˜¯æ€ä¹ˆå†™
3. **åŠ¨æ‰‹å®è·µ**ï¼šå°è¯•ä¿®æ”¹ä»£ç ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ
4. **æµ‹è¯•é©±åŠ¨**ï¼šå…ˆå†™æµ‹è¯•ï¼Œå†å†™ä»£ç 
5. **å®‰å…¨ç¬¬ä¸€**ï¼šå§‹ç»ˆè€ƒè™‘å¯èƒ½çš„æ”»å‡»å‘é‡

è®°ä½ï¼š**å¥½çš„ä»£ç ä¸ä»…è¦èƒ½å·¥ä½œï¼Œè¿˜è¦å®‰å…¨ã€é«˜æ•ˆã€æ˜“äºç†è§£ï¼** ğŸš€