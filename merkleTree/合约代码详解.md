# 📖 智能合约代码详解

> 逐行解读三个核心合约，让你彻底理解每一行代码的作用

---

## 🏗️ 合约概览

项目包含三个智能合约，就像搭积木一样：

```
🏪 AirdropMerkleNFTMarket (主合约 - 商店大脑)
├── 💰 AirdropToken (代币合约 - 商店货币)
└── 🖼️ AirdropNFT (NFT合约 - 商店商品)
```

---

## 💰 AirdropToken.sol - 代币合约详解

### 📋 合约结构

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
```

**这些导入是什么意思？**
- `ERC20`：基础代币功能（转账、余额查询等）
- `ERC20Permit`：签名授权功能（免 gas 授权）
- `Ownable`：所有者权限控制

### 🏗️ 合约定义

```solidity
contract AirdropToken is ERC20, ERC20Permit, Ownable {
    constructor(
        string memory name,
        string memory symbol,
        address initialOwner
    ) ERC20(name, symbol) ERC20Permit(name) Ownable(initialOwner) {}
```

**通俗解释**：
- 这就像开一家银行，发行自己的货币
- `name`：货币名称（比如"空投币"）
- `symbol`：货币符号（比如"AIRDROP"）
- `initialOwner`：银行行长（有特殊权限）

### 💎 核心功能函数

#### 1. 铸造代币（印钞票）

```solidity
function mint(address to, uint256 amount) external onlyOwner {
    _mint(to, amount);
}
```

**作用**：创造新的代币
**比喻**：就像央行印钞票
**权限**：只有合约所有者可以调用
**参数**：
- `to`：给谁发代币
- `amount`：发多少代币

#### 2. 销毁代币（销毁钞票）

```solidity
function burn(uint256 amount) external {
    _burn(msg.sender, amount);
}
```

**作用**：销毁自己的代币
**比喻**：把钞票烧掉，减少流通量
**权限**：任何人都可以销毁自己的代币
**参数**：
- `amount`：要销毁的数量

### 🔐 Permit 功能详解

**传统授权流程**：
1. 用户调用 `approve(spender, amount)` - 花费 gas
2. 商店调用 `transferFrom(user, shop, amount)` - 花费 gas

**Permit 授权流程**：
1. 用户在链下签名 - 不花费 gas
2. 商店调用 `permit()` + `transferFrom()` - 只花费一次 gas

```solidity
// 这个函数继承自 ERC20Permit，不需要我们实现
function permit(
    address owner,      // 代币所有者
    address spender,    // 被授权者
    uint256 value,      // 授权金额
    uint256 deadline,   // 授权截止时间
    uint8 v,           // 签名参数
    bytes32 r,         // 签名参数
    bytes32 s          // 签名参数
) external;
```

---

## 🖼️ AirdropNFT.sol - NFT合约详解

### 📋 合约结构

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
```

**导入说明**：
- `ERC721`：NFT 标准实现
- `Ownable`：权限控制

### 🏗️ 合约定义和状态变量

```solidity
contract AirdropNFT is ERC721, Ownable {
    uint256 private _tokenIdCounter;
    
    // NFT 市场相关
    mapping(uint256 => uint256) public tokenPrices;
    mapping(uint256 => bool) public tokenListed;
    
    // 事件定义
    event TokenListed(uint256 indexed tokenId, uint256 price);
    event TokenUnlisted(uint256 indexed tokenId);
    event TokenPriceUpdated(uint256 indexed tokenId, uint256 newPrice);
```

**状态变量解释**：
- `_tokenIdCounter`：NFT 编号计数器（从 1 开始）
- `tokenPrices`：每个 NFT 的价格
- `tokenListed`：NFT 是否在售

**事件解释**：
- 事件就像"广播"，告诉外界发生了什么
- 前端可以监听这些事件来更新界面

### 🎨 NFT 铸造功能

```solidity
function mint(address to, string memory tokenURI) external onlyOwner returns (uint256) {
    _tokenIdCounter++;
    uint256 tokenId = _tokenIdCounter;
    _mint(to, tokenId);
    _setTokenURI(tokenId, tokenURI);
    return tokenId;
}
```

**逐行解释**：
1. `_tokenIdCounter++`：编号加 1（第一个 NFT 是 #1）
2. `uint256 tokenId = _tokenIdCounter`：获取当前编号
3. `_mint(to, tokenId)`：创建 NFT 并分配给 `to`
4. `_setTokenURI(tokenId, tokenURI)`：设置 NFT 的元数据链接
5. `return tokenId`：返回新创建的 NFT 编号

**比喻**：就像工厂生产商品，每个商品都有唯一的序列号

### 🏪 市场功能

#### 1. 上架商品

```solidity
function listToken(uint256 tokenId, uint256 price) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    require(price > 0, "Price must be greater than 0");
    
    tokenPrices[tokenId] = price;
    tokenListed[tokenId] = true;
    
    emit TokenListed(tokenId, price);
}
```

**逐行解释**：
1. `require(ownerOf(tokenId) == msg.sender, "Not the owner")`：检查是否是 NFT 主人
2. `require(price > 0, "Price must be greater than 0")`：检查价格是否有效
3. `tokenPrices[tokenId] = price`：设置价格
4. `tokenListed[tokenId] = true`：标记为在售
5. `emit TokenListed(tokenId, price)`：发出上架事件

#### 2. 下架商品

```solidity
function unlistToken(uint256 tokenId) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    
    tokenListed[tokenId] = false;
    tokenPrices[tokenId] = 0;
    
    emit TokenUnlisted(tokenId);
}
```

**作用**：NFT 主人可以下架自己的商品

#### 3. 更新价格

```solidity
function updateTokenPrice(uint256 tokenId, uint256 newPrice) external {
    require(ownerOf(tokenId) == msg.sender, "Not the owner");
    require(tokenListed[tokenId], "Token not listed");
    require(newPrice > 0, "Price must be greater than 0");
    
    tokenPrices[tokenId] = newPrice;
    
    emit TokenPriceUpdated(tokenId, newPrice);
}
```

**作用**：修改已上架 NFT 的价格

### 📊 查询功能

```solidity
function getCurrentTokenId() external view returns (uint256) {
    return _tokenIdCounter;
}

function batchMint(address to, string[] memory tokenURIs) external onlyOwner returns (uint256[] memory) {
    uint256[] memory tokenIds = new uint256[](tokenURIs.length);
    
    for (uint256 i = 0; i < tokenURIs.length; i++) {
        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;
        _mint(to, tokenId);
        _setTokenURI(tokenId, tokenURIs[i]);
        tokenIds[i] = tokenId;
    }
    
    return tokenIds;
}
```

**批量铸造解释**：
- 一次性创建多个 NFT
- 返回所有新创建的 NFT 编号
- 提高效率，节省 gas

---

## 🏪 AirdropMerkleNFTMarket.sol - 主合约详解

### 📋 合约结构和导入

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./AirdropToken.sol";
import "./AirdropNFT.sol";
```

**导入说明**：
- `ReentrancyGuard`：防止重入攻击
- `MerkleProof`：验证 Merkle 证明
- `Ownable`：权限控制
- 自定义合约：代币和 NFT 合约

### 🏗️ 状态变量

```solidity
contract AirdropMerkleNFTMarket is ReentrancyGuard, Ownable {
    AirdropToken public immutable token;
    AirdropNFT public immutable nft;
    bytes32 public merkleRoot;
    uint256 public constant DISCOUNT_RATE = 50; // 50% 折扣
    
    mapping(address => bool) public hasClaimed;
    mapping(address => uint256) public prepaidAmounts;
```

**变量解释**：
- `token`：代币合约地址（不可变）
- `nft`：NFT 合约地址（不可变）
- `merkleRoot`：白名单的 Merkle 根哈希
- `DISCOUNT_RATE`：折扣率（50%）
- `hasClaimed`：记录谁已经领取过
- `prepaidAmounts`：记录预付款金额

### 🎯 核心功能详解

#### 1. 白名单验证

```solidity
function verifyWhitelist(address user, bytes32[] calldata proof) public view returns (bool) {
    bytes32 leaf = keccak256(abi.encodePacked(user));
    return MerkleProof.verify(proof, merkleRoot, leaf);
}
```

**工作原理**：
1. `keccak256(abi.encodePacked(user))`：把用户地址转换成叶子节点
2. `MerkleProof.verify(proof, merkleRoot, leaf)`：验证证明路径
3. 返回 `true` 表示用户在白名单中

**比喻**：就像验证学生证，检查学号是否在学校数据库中

#### 2. 计算折扣价格

```solidity
function calculateDiscountedPrice(uint256 originalPrice) public pure returns (uint256) {
    return (originalPrice * DISCOUNT_RATE) / 100;
}
```

**作用**：白名单用户享受 50% 折扣
**计算**：原价 × 50 ÷ 100 = 折扣价

#### 3. Permit 预付款

```solidity
function permitPrePay(
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
) external {
    // 使用 permit 授权
    token.permit(msg.sender, address(this), value, deadline, v, r, s);
    
    // 转移代币到合约
    token.transferFrom(msg.sender, address(this), value);
    
    // 记录预付款
    prepaidAmounts[msg.sender] += value;
    
    emit PrePaid(msg.sender, value);
}
```

**逐步解释**：
1. **permit 授权**：用签名代替传统的 approve
2. **转移代币**：把用户的代币转到合约中
3. **记录预付款**：记录用户预付了多少钱
4. **发出事件**：通知外界预付款成功

**比喻**：就像充值会员卡，先把钱存到卡里

#### 4. 领取 NFT（核心功能）

```solidity
function claimNFT(uint256 tokenId, bytes32[] calldata proof) external nonReentrant {
    // 检查 NFT 是否在售
    require(nft.tokenListed(tokenId), "Token not listed");
    
    // 检查是否已经领取过
    require(!hasClaimed[msg.sender], "Already claimed");
    
    // 获取原价
    uint256 originalPrice = nft.tokenPrices(tokenId);
    require(originalPrice > 0, "Invalid price");
    
    uint256 finalPrice;
    
    // 验证白名单并计算价格
    if (verifyWhitelist(msg.sender, proof)) {
        finalPrice = calculateDiscountedPrice(originalPrice);
    } else {
        finalPrice = originalPrice;
    }
    
    // 检查预付款是否足够
    require(prepaidAmounts[msg.sender] >= finalPrice, "Insufficient prepaid amount");
    
    // 扣除预付款
    prepaidAmounts[msg.sender] -= finalPrice;
    
    // 标记已领取
    hasClaimed[msg.sender] = true;
    
    // 获取 NFT 当前所有者
    address nftOwner = nft.ownerOf(tokenId);
    
    // 转移 NFT
    nft.transferFrom(nftOwner, msg.sender, tokenId);
    
    // 支付给 NFT 所有者
    token.transfer(nftOwner, finalPrice);
    
    emit NFTClaimed(msg.sender, tokenId, finalPrice);
}
```

**详细流程解释**：

1. **安全检查**：
   - NFT 必须在售
   - 用户不能重复领取
   - 价格必须有效

2. **价格计算**：
   - 验证 Merkle 证明
   - 白名单用户：50% 折扣
   - 非白名单用户：原价

3. **支付处理**：
   - 检查预付款是否足够
   - 扣除相应金额
   - 标记已领取状态

4. **NFT 转移**：
   - 从原所有者转移给购买者
   - 支付代币给原所有者

#### 5. Multicall 批量操作

```solidity
function multicall(bytes[] calldata data) external returns (bytes[] memory results) {
    results = new bytes[](data.length);
    
    for (uint256 i = 0; i < data.length; i++) {
        (bool success, bytes memory result) = address(this).delegatecall(data[i]);
        
        if (!success) {
            // 如果调用失败，抛出错误
            if (result.length < 68) revert("Multicall failed");
            assembly {
                result := add(result, 0x04)
            }
            revert(abi.decode(result, (string)));
        }
        
        results[i] = result;
    }
}
```

**工作原理**：
1. **循环处理**：遍历所有要执行的调用
2. **delegatecall**：在当前合约上下文中执行调用
3. **错误处理**：如果任何一个调用失败，整个交易回滚
4. **返回结果**：收集所有调用的返回值

**使用场景**：
```solidity
// 一次交易完成：预付款 + 领取 NFT
bytes[] memory calls = new bytes[](2);
calls[0] = abi.encodeWithSelector(this.permitPrePay.selector, amount, deadline, v, r, s);
calls[1] = abi.encodeWithSelector(this.claimNFT.selector, tokenId, proof);
this.multicall(calls);
```

### 🔧 管理功能

#### 1. 更新 Merkle Root

```solidity
function updateMerkleRoot(bytes32 newMerkleRoot) external onlyOwner {
    merkleRoot = newMerkleRoot;
    emit MerkleRootUpdated(newMerkleRoot);
}
```

**作用**：管理员可以更新白名单

#### 2. 紧急提取

```solidity
function emergencyWithdraw() external onlyOwner {
    uint256 balance = token.balanceOf(address(this));
    token.transfer(owner(), balance);
    emit EmergencyWithdraw(owner(), balance);
}
```

**作用**：紧急情况下提取合约中的代币

### 📊 查询功能

```solidity
function getContractTokenBalance() external view returns (uint256) {
    return token.balanceOf(address(this));
}

function getUserPrepaidAmount(address user) external view returns (uint256) {
    return prepaidAmounts[user];
}

function hasUserClaimed(address user) external view returns (bool) {
    return hasClaimed[user];
}
```

**作用**：提供各种查询接口，方便前端调用

---

## 🔒 安全机制详解

### 1. 重入攻击防护

```solidity
modifier nonReentrant() {
    require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
    _status = _ENTERED;
    _;
    _status = _NOT_ENTERED;
}
```

**工作原理**：
- 函数开始时设置状态为"已进入"
- 如果函数还在执行时被再次调用，会被拒绝
- 函数结束时重置状态

### 2. 权限控制

```solidity
modifier onlyOwner() {
    require(owner() == msg.sender, "Ownable: caller is not the owner");
    _;
}
```

**作用**：确保只有合约所有者可以执行敏感操作

### 3. 输入验证

```solidity
require(nft.tokenListed(tokenId), "Token not listed");
require(!hasClaimed[msg.sender], "Already claimed");
require(originalPrice > 0, "Invalid price");
```

**原则**：永远不要信任用户输入，必须验证所有参数

---

## 🎯 关键设计模式

### 1. 工厂模式

合约在构造函数中接收其他合约的地址：

```solidity
constructor(
    address tokenAddress,
    address nftAddress,
    bytes32 initialMerkleRoot,
    address initialOwner
) Ownable(initialOwner) {
    token = AirdropToken(tokenAddress);
    nft = AirdropNFT(nftAddress);
    merkleRoot = initialMerkleRoot;
}
```

### 2. 状态机模式

用户状态的变化：
```
未预付 → 已预付 → 已领取
```

### 3. 事件驱动模式

所有重要操作都会发出事件：
```solidity
event PrePaid(address indexed user, uint256 amount);
event NFTClaimed(address indexed user, uint256 indexed tokenId, uint256 price);
event MerkleRootUpdated(bytes32 newMerkleRoot);
```

---

## 💡 优化技巧

### 1. Gas 优化

- 使用 `immutable` 变量减少存储读取
- 批量操作减少交易次数
- 合理的数据结构设计

### 2. 用户体验优化

- Permit 机制减少交易步骤
- Multicall 支持批量操作
- 详细的错误信息

### 3. 安全优化

- 完整的输入验证
- 重入攻击防护
- 权限控制

---

## 🤔 常见问题

### Q: 为什么要用 `immutable` 修饰符？

**A**: 
- `immutable` 变量在部署时设置，之后不能修改
- 读取 `immutable` 变量比读取普通状态变量更便宜
- 提供了安全性保证

### Q: `delegatecall` 和 `call` 有什么区别？

**A**:
- `call`：在目标合约的上下文中执行
- `delegatecall`：在当前合约的上下文中执行目标合约的代码
- Multicall 使用 `delegatecall` 保持状态一致性

### Q: 为什么要检查 `hasClaimed`？

**A**:
- 防止用户多次领取同一个 NFT
- 确保每个用户只能享受一次折扣
- 维护系统的公平性

---

## 📚 学习建议

1. **逐行阅读**：不要跳过任何一行代码
2. **理解原理**：知道为什么这样写，而不只是怎么写
3. **动手实践**：尝试修改代码，看看会发生什么
4. **测试驱动**：先写测试，再写代码
5. **安全第一**：始终考虑可能的攻击向量

记住：**好的代码不仅要能工作，还要安全、高效、易于理解！** 🚀