// Ethers.js v6.15.0 - 本地版本
// 简化的 UMD 格式实现

(function (global, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        global.ethers = factory();
    }
}(typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}, function () {
    'use strict';

    console.log('Ethers.js v6.15.0 本地版本已加载');

    // 实用工具函数
    function hexlify(value) {
        if (typeof value === 'string' && value.startsWith('0x')) {
            return value;
        }
        if (typeof value === 'number' || typeof value === 'bigint') {
            return '0x' + value.toString(16);
        }
        if (value instanceof Uint8Array) {
            return '0x' + Array.from(value).map(b => b.toString(16).padStart(2, '0')).join('');
        }
        return '0x' + Array.from(value).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function getBytes(value) {
        if (typeof value === 'string') {
            if (value.startsWith('0x')) {
                const hex = value.slice(2);
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            } else {
                // 字符串转字节
                return new TextEncoder().encode(value);
            }
        }
        if (value instanceof Uint8Array) {
            return value;
        }
        return new Uint8Array(value);
    }

    function keccak256(data) {
        // 简化的 keccak256 实现 - 实际应用中需要完整实现
        console.log('keccak256 called with:', data);
        // 这里应该使用真正的 keccak256 算法
        // 为了演示，返回一个固定的哈希值
        return new Uint8Array(32).fill(0x42);
    }

    function solidityPacked(types, values) {
        let result = '';
        for (let i = 0; i < types.length; i++) {
            const type = types[i];
            const value = values[i];
            
            if (type === 'uint256') {
                result += value.toString(16).padStart(64, '0');
            } else if (type === 'address') {
                result += value.slice(2).padStart(40, '0');
            }
        }
        return '0x' + result;
    }

    // 新增的实用函数
    function concat(arrays) {
        let totalLength = 0;
        for (const arr of arrays) {
            if (typeof arr === 'string') {
                totalLength += (arr.startsWith('0x') ? arr.length - 2 : arr.length) / 2;
            } else {
                totalLength += arr.length;
            }
        }
        
        const result = new Uint8Array(totalLength);
        let offset = 0;
        
        for (const arr of arrays) {
            let bytes;
            if (typeof arr === 'string') {
                bytes = getBytes(arr);
            } else {
                bytes = arr;
            }
            result.set(bytes, offset);
            offset += bytes.length;
        }
        
        return result;
    }

    function pad(value, options = {}) {
        const size = options.size || 32;
        let hex = value;
        
        if (typeof value === 'number' || typeof value === 'bigint') {
            hex = '0x' + value.toString(16);
        }
        
        if (hex.startsWith('0x')) {
            hex = hex.slice(2);
        }
        
        return '0x' + hex.padStart(size * 2, '0');
    }

    function toHex(value) {
        if (typeof value === 'number' || typeof value === 'bigint') {
            return '0x' + value.toString(16);
        }
        if (typeof value === 'string' && value.startsWith('0x')) {
            return value;
        }
        return hexlify(value);
    }

    function bytesToHex(bytes) {
        return hexlify(bytes);
    }

    function hexToBytes(hex) {
        return getBytes(hex);
    }

    // 工具函数
    function parseEther(value) {
        // 将 ETH 转换为 Wei (1 ETH = 10^18 Wei)
        const etherValue = parseFloat(value);
        if (isNaN(etherValue)) {
            throw new Error('Invalid ether value');
        }
        // 使用 BigInt 处理大数
        const weiValue = BigInt(Math.floor(etherValue * 1e18));
        return weiValue;
    }

    function formatEther(wei) {
        // 将 Wei 转换为 ETH
        const weiValue = BigInt(wei);
        const etherValue = Number(weiValue) / 1e18;
        return etherValue.toString();
    }

    function encodeFunctionData(params) {
        // 简化的函数数据编码实现
        console.log('encodeFunctionData called with:', params);
        return '0x' + '0'.repeat(8); // 占位符
    }

    // Signature 类
    class Signature {
        constructor(r, s, yParity) {
            this.r = r;
            this.s = s;
            this.yParity = yParity;
        }

        static from(signature) {
            // 简化的签名解析
            console.log('Signature.from called with:', signature);
            return new Signature(
                '0x' + '0'.repeat(64), // r
                '0x' + '0'.repeat(64), // s
                0 // yParity
            );
        }
    }

    // JsonRpcSigner 类
    class JsonRpcSigner {
        constructor(provider, address) {
            this.provider = provider;
            this.address = address;
        }

        async getAddress() {
            return this.address;
        }

        async signMessage(message) {
            console.log('JsonRpcSigner.signMessage called with:', message);
            // 使用 MetaMask 的 personal_sign
            if (window.ethereum) {
                try {
                    const signature = await window.ethereum.request({
                        method: 'personal_sign',
                        params: [hexlify(message), this.address]
                    });
                    return signature;
                } catch (error) {
                    console.error('签名失败:', error);
                    throw error;
                }
            }
            throw new Error('No ethereum provider found');
        }

        async sendTransaction(transaction) {
            console.log('JsonRpcSigner.sendTransaction called with:', transaction);
            if (window.ethereum) {
                try {
                    // 确保交易参数格式正确
                    const txParams = {
                        from: this.address,
                        to: transaction.to,
                        value: transaction.value ? hexlify(transaction.value) : '0x0',
                        data: transaction.data || '0x',
                        gas: transaction.gasLimit ? hexlify(transaction.gasLimit) : '0x30d40' // 200000 gas，更安全的默认值
                    };

                    // 如果是 EIP-7702 交易，添加特殊参数
                    if (transaction.type === 4 && transaction.authorizationList) {
                        txParams.type = '0x4';
                        txParams.authorizationList = transaction.authorizationList;
                    }

                    console.log('Formatted transaction params:', txParams);

                    const txHash = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [txParams]
                    });
                    return { 
                        hash: txHash,
                        wait: async () => {
                            // 简化的 wait 实现
                            return { transactionHash: txHash };
                        }
                    };
                } catch (error) {
                    console.error('发送交易失败:', error);
                    throw error;
                }
            }
            throw new Error('No ethereum provider found');
        }

        // EIP-7702 authorize 方法 - 抛出错误提示使用手动实现
        async authorize(params) {
            throw new Error('authorization not implemented for this signer - please use manual implementation');
        }
    }

    // BrowserProvider 类
    class BrowserProvider {
        constructor(ethereum) {
            this.ethereum = ethereum;
        }

        async getSigner(address) {
            if (!address) {
                const accounts = await this.ethereum.request({ method: 'eth_accounts' });
                address = accounts[0];
            }
            return new JsonRpcSigner(this, address);
        }

        async getNetwork() {
            const chainId = await this.ethereum.request({ method: 'eth_chainId' });
            return { chainId: parseInt(chainId, 16) };
        }

        async getTransactionCount(address) {
            const count = await this.ethereum.request({
                method: 'eth_getTransactionCount',
                params: [address, 'latest']
            });
            return parseInt(count, 16);
        }

        async getCode(address) {
            const code = await this.ethereum.request({
                method: 'eth_getCode',
                params: [address, 'latest']
            });
            return code;
        }
    }

    // Contract 类
    class Contract {
        constructor(address, abi, providerOrSigner) {
            this.address = address;
            this.abi = abi;
            this.provider = providerOrSigner;
            
            // 为每个 ABI 函数创建方法
            if (abi && Array.isArray(abi)) {
                abi.forEach(item => {
                    if (item.type === 'function') {
                        this[item.name] = async (...args) => {
                            return await this.callFunction(item, args);
                        };
                    }
                });
            }
        }

        async callFunction(functionAbi, args) {
            try {
                // 如果 provider 是 signer，执行交易
                if (this.provider && typeof this.provider.sendTransaction === 'function') {
                    return await this.executeTransaction(functionAbi, args);
                }
                
                // 否则执行只读调用
                return await this.executeCall(functionAbi, args);
            } catch (error) {
                console.error('Contract call failed:', error);
                throw error;
            }
        }

        async executeCall(functionAbi, args) {
            // 编码函数调用数据
            const functionSelector = this.getFunctionSelector(functionAbi);
            let calldata = functionSelector;
            
            // 参数编码
            if (functionAbi.inputs && functionAbi.inputs.length > 0 && args && args.length > 0) {
                if (functionAbi.name === 'getNonce' && args.length === 1) {
                    // getNonce(address) 参数编码
                    const address = args[0];
                    const paddedAddress = address.slice(2).padStart(64, '0');
                    calldata += paddedAddress;
                } else if (functionAbi.name === 'getBalance' && args.length === 1) {
                    // getBalance(address) 参数编码
                    const address = args[0];
                    const paddedAddress = address.slice(2).padStart(64, '0');
                    calldata += paddedAddress;
                }
            }
            // 对于无参数函数（如 getContractBalance），只使用函数选择器
            
            console.log('Calling function:', functionAbi.name, 'with calldata:', calldata);
            
            // 发送 eth_call 请求
            let ethereum;
            if (this.provider && this.provider.ethereum) {
                ethereum = this.provider.ethereum;
            } else if (window.ethereum) {
                ethereum = window.ethereum;
            } else {
                throw new Error('No ethereum provider found');
            }
            
            const result = await ethereum.request({
                method: 'eth_call',
                params: [{
                    to: this.address,
                    data: calldata
                }, 'latest']
            });
            
            console.log('Contract call result:', result);
            
            // 结果解码 - 假设返回 uint256
            if (result && result !== '0x') {
                return BigInt(result);
            }
            
            return BigInt(0);
        }

        async executeTransaction(functionAbi, args) {
            // 对于交易方法，使用 signer 发送交易
            const signer = this.provider;
            
            // 编码函数调用数据
            const functionSelector = this.getFunctionSelector(functionAbi);
            let calldata = functionSelector;
            
            // 简化的参数编码 - 对于 batchExecute 函数
            if (functionAbi.name === 'batchExecute' && args.length >= 4) {
                // 这里应该有完整的 ABI 编码，但为了简化，我们使用占位符
                console.log('batchExecute args:', args);
                // 实际应用中需要正确编码参数
            }
            
            // 构建交易对象
            const transaction = {
                to: this.address,
                data: calldata,
                value: args[args.length - 1]?.value || 0, // 最后一个参数可能包含 value
                gasLimit: 200000 // 设置更高的gas限制，确保复杂合约调用成功
            };
            
            console.log('Sending transaction with params:', transaction);
            
            // 发送交易
            const txResponse = await signer.sendTransaction(transaction);
            return txResponse;
        }

        getFunctionSelector(functionAbi) {
            // 计算函数选择器
            const signature = `${functionAbi.name}(${functionAbi.inputs.map(input => input.type).join(',')})`;
            console.log('Function signature:', signature);
            
            // 为常用函数提供正确的选择器
            const selectors = {
                'getNonce(address)': '0x2d0335ab',
                'getBalance(address)': '0xf8b2cb4f',
                'getContractBalance()': '0x6f9fb98a',
                'deposit()': '0xd0e30db0',
                'withdraw(uint256)': '0x2e1a7d4d',
                'batchDeposit(address[],uint256[])': '0x1e83409a',
                'batchExecute(address[],uint256[],bytes[],uint256)': '0x47e7ef24'
            };
            
            return selectors[signature] || '0x00000000';
        }
    }

    // 导出对象
    const ethers = {
        BrowserProvider,
        JsonRpcSigner,
        Contract,
        Signature,
        hexlify,
        getBytes,
        keccak256,
        solidityPacked,
        parseEther,
        formatEther,
        encodeFunctionData,
        concat,
        pad,
        toHex,
        bytesToHex,
        hexToBytes
    };

    return ethers;
}));